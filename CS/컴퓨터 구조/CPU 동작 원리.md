## CPU 동작 원리

### 언어의 수준
+ 기계어 (Machine Code)
    - CPU가 직접 실행하는 코드
    - CPU가 이해할 수 있는 가장 낮은 수준(Low Level)의 명령어
    - 예 : 10110000
+ 어셈블리어
    - 인간이 읽고 작성할 수 있는 언어와 컴퓨터가 이해할 수 있는 기계어의 중간 단계 언어
    - 데이터 이동, 레지스터 조작, 메모리 접근 등 하드웨어를 직접 제어
    - 어셈블리어는 1:1로 기계어 명령어에 대응

### 명령어의 형태

![명령어의 형태](./images/명령어의%20형태.png)

+ 연산코드
    - 수행할 연산을 지정
    - 데이터 이동, 제어 명령 등
+ 오퍼랜드
    - 피연산자, 연산에 사용될 데이터 또는 데이터의 위치
    - 레지스터, 메모리 주소, 특정 값
+ 명령어의 예시
    ```
    ADD R1, R2
    // R1 레지스터와 R2 레지스터의 데이터를 더해라
    ```

### 명령어의 종류
+ 데이터 전송 명령어
    - 데이터를 이동하는 명령
    - LOAD R1, 100
    - STORE R1, 200
+ 산술 및 논리 명령어
    - 산술 연산(덧셈, 뺄셈 등)과 논리 연산(AND, OR 등)을 수행
    - ADD R1, R2
    - AND R1, R2
+ 제어 명령어
    - 프로그램 실행 순서를 변경하는 명령
        + JMP 400 : 프로그램을 주소 400으로 이동
        + BEQ R1, R2, 500 : R1과 R2가 같으면 주소 500으로 이동
+ 입출력 명령어
    - 외부 장치와 데이터를 교환
    - IN R1, 0xFF : 입력 장치 0xFF에서 데이터를 읽어 R1에 저장
    - OUT R1, OxFF : R1의 데이터를 출력 장치 OxFF로 이동

### 오퍼랜드 주소 지정 방식
오퍼랜드 주소 지정 방식을 공부하기 전에 주소 표기 방법을 확인해야 한다  

|정의내용|표기방법|
|---|---|
|유효 주소(기억 장치의 실제 주소)|EA|
|기억 장치 주소|A|
|레지스터 번호|R|
|기억 장치 A번지의 내용|(A)|
|레지스터 R번지의 내용|(R)|

오퍼랜드에 값이 저장되는 방식은 다양하다  
데이터의 실제 값 또는 데이터가 저장된 주소를 저장한다  

+ 직접 주소 지정 방식
    - 가장 기본적인 방식으로 오퍼랜드가 데이터가 저장된 메모리의 실제 주소를 가리킴
    - EA = A
    - 장점 : 데이터 인출을 위해 기억 장치에 1번만 접근
    - 단점
        + 오퍼랜드 필드의 비트 수에 의해 지정할 수 있는 기억 장소의 수가 제한됨
        + 12비트 오퍼랜드면 2의 12제곱인 4096개의 주소만 접근이 가능

    ![직접 주소 지정 방식 예시](./images/직접%20주소%20지정%20방식.png)

+ 간접 주소 지정 방식
    - 오퍼랜드가 데이터의 주소를 저장한 다른 주소를 가리킴
    - EA = (A)
    - 장점 : 주소를 동적으로 변경할 수 있어 유연성이 높음 (데이터의 주소가 바뀌어도 A의 주소만 변경, 명령어 변경할 필요 X)
    - 단점
        + 기억 장치에 두번 접근해야되서 속도가 느림
        + 데이터의 주소를 읽고, 실제 데이터를 얻기 위해
    - 과정
        + 12비트 오퍼랜드에 중간 주소 저장 (ex) 1000번지)
        + 1000번지에 저장된 값은 `전체 메모리 주소 크기` (ex) 16비트, 32비트 등)
        + 따라서 12비트 제한을 넘어 더 많은 메모리 주소에 접근이 가능
    - 왜 이렇게 설계했을까?
        + 명령어를 짧게 유지하면서 (명령어 길이 제한)
        + 더 넓은 메모리 접근 가능 (메모리 주소 공간 확장)

    ![간접 주소 지정 방식 예시](./images/간접%20주소%20지정%20방식.png)

+ 즉시 주소 지정 방식
    - 오퍼랜드가 실제 데이터를 저장함 (데이터가 명령어어ㅔ 포함되어 있음, 오퍼랜드 필드가 실제 데이터)
    - 장점 : 데이터를 인출하기 위해 기억 장치에 접근할 필요가 없어 빠르다
    - 단점 : 오퍼랜드 필드의 비트 수에 의해 값의 크기가 제한
+ 레지스터 주소 지정 방식
    - 데이터가 레지스터에 저장되어 있고 오퍼랜드는 레지스터 주소를 가리킴
    - EA = R
    - 장점 : 기억 장치에 접근할 필요가 없어 속도가 빠름
    - 단점 : 데이터를 저장할 수 있는 공간이 CPU 내부의 레지스터로 제한

### 명령어 집합
CPU가 이해하고 실행할 수 있는 명령어들의 모음  
CPU에 따라 명령어 집합은 달라질 수 있다

+ CISC (Complex Instruction Set Computer)
    - x86 아키텍처(Intel, AMD) 기반 CPU의 명령어 집합
    - 복잡한 명령어로 구성되어 있음
    - 명령어의 길이가 다양하고 명령어마다 명령어의 실행시간이 다름
    - 복잡한 대신 하나의 명령어가 많은 일을 할 수 있기 때문에 메모리를 절약 가능
        ```
        [연산코드][주소지정모드][오퍼랜드1][오퍼랜드2][변위/즉시값]
        - 가변 길이: 1바이트 ~ 15바이트까지 (예: x86)
        - 복잡한 작업 가능
        ```
+ RISC (Reduced Instruction Set Computer)
    - ARM 등 CPU의 명령어 집합
    - 단순한 명령어로 구성되어 있고 명령어 길이가 고정
    - 길이가 고정되어 있으므로 실행속도가 빠르고 실행시간이 대부분 일정
        ```
        [연산코드][레지스터1][레지스터2][레지스터3]
        - 고정 길이: 32비트 (예: ARM, MIPS)
        - 단순한 작업만: ADD R1, R2, R3  (레지스터끼리만 연산)
        ```

CISC가 RISC에 비해 좀 더 복잡하다고 하는데, 여기서 복잡하다는 것은 어떠한 의미일까?  
메모리의 두 값을 더해서 저장하는 작업을 예로 들어보자  

+ CISC (한 명령어로 가능)
    ```
    ADD [주소C], [주소A], [주소B]

    > 1개 명령어, 가변 길이 (예: 80비트)
    > 명령어는 복잡, 개수는 적음
    ```
+ RISC (여러 명령어 필요)
    ```
    LOAD  R1, [주소A]    // 메모리 → 레지스터
    LOAD  R2, [주소B]    // 메모리 → 레지스터  
    ADD   R3, R1, R2     // 레지스터끼리 덧셈
    STORE R3, [주소C]    // 레지스터 → 메모리

    > 4개 명령어, 각 32비트 = 총 128비트
    > 명령어는 단순, 개수는 많음
    ```

그래서 CISC가 복잡한 이유는?  

+ 명령어에 추가 요소가 존재
    ```
    [Prefix][연산코드][ModR/M][SIB][Displacement][Immediate]

    - ModR/M: 주소 지정 모드 지정
    - SIB: Scale-Index-Base (배열 접근용)
    - Displacement: 변위값
    - Immediate: 즉시값
    ```
+ 다양한 오퍼랜드를 사용할 수 있어서
    ```
    CISC는 오퍼랜드가:
    - 레지스터일 수도
    - 메모리 주소일 수도  
    - 즉시값일 수도
    - 레지스터 간접 주소일 수도
    - 베이스+인덱스+오프셋 조합일 수도

    > 이걸 표현하려면 추가 비트 필요!
    ```
+ 연산 자체가 복잡
    ```
    RISC: ADD, SUB, LOAD, STORE 같은 단순 연산만
    CISC: 문자열 복사, 배열 검색, 삼각함수 등도 명령어로 제공

    예) x86의 REP MOVSB
    > 문자열 전체를 한 명령어로 복사
    > 내부적으로 반복문 실행
    ```

| 구분 | RISC | CISC |
|------|------|------|
| 명령어 길이 | 고정 (32비트) | 가변 (1~15바이트) |
| 명령어 개수 | 많음 | 적음 |
| 추가 요소 | 없음 (단순 구조) | 많음 (ModR/M, SIB 등) |
| 오퍼랜드 | 주로 레지스터만 | 레지스터+메모리+즉시값 |
| 한 명령어가 하는 일 | 한 가지 | 여러 가지 |