## 주기억 장치와 보조 기억 장치
컴퓨터에서 데이터를 저장하는 공간을 `기억장치`라고 한다  
기억장치는 두가지로 나뉜다

### 주기억장치
+ CPU가 직접 접근할 수 있는 메모리
+ 프로그램 실행 중 필요한 데이터를 임시로 저장하는 공간
+ 컴퓨터의 데이터를 읽기 및 쓰기 작업에 빠르게 접근할 수 있도록 설계됨
+ 역할
    - 프로그램 명령어 저장
        + 실행 중인 프로그램의 명령어가 저장
        + CPU는 명령어를 명령어 사이클(인출 > 해독 > 실행)에 따라 처리
    - 데이터 저장
        + 프로그램이 처리하는 데이터가 저장
        + 연산 중인 중간 값과 최종 결과도 저장
    - CPU와 저장장치 사이의 데이터 중계
        + 주기억 장치는 CPU와 보조기억장치 사이에서 데이터를 빠르게 전달하는 역할
+ 특징
    - 휘발성 메모리
    - CPU는 주기억장치에 직접 접근하여 데이터를 읽고 쓸 수 있다

주기억장치는 RAM (Random Access Memory)과 ROM (Read-Only Memory) 두 종류가 있다  

### MMU의 주소 변환
+ MMU (Memory Management Unit)
    - CPU와 메모리 사이에 있는 하드웨어 장치
        ```
        [CPU] ←→ [MMU] ←→ [RAM]
                 논리주소    물리주소
        ```
        + CPU가 메모리에 접근할 때, 직접 접근하는 것이 아닌 MMU를 거쳐서 접근한다

MMU에 대해서 더 설명하기 전에 두가지 주소 개념에 대해 이해해야 한다  

+ 논리 주소 (Logical Address)
    - CPU와 프로그램이 사용하는 가상의 주소
    - 각 프로그램마다 독립적으로 0번지부터 시작
    - 프로그램이 보는 주소
+ 물리 주소 (Physical Address)
    - 실제 RAM에서의 진짜 주소
    - 하드웨어 상의 위치
    - 메모리가 보는 주소
+ 주소 변환 과정
    ```
    1단계: CPU가 명령어 실행
        ↓
        "0x1000 번지의 데이터를 읽어와!"
    
    2단계: MMU가 주소 변환표(Page Table) 확인
        ↓
        논리 주소 0x1000 → 물리 주소 0x5A3000 찾기
    
    3단계: 실제 RAM의 0x5A3000 번지 접근
        ↓
        데이터 읽기
    
    4단계: CPU에게 데이터 전달
    ```

왜 복잡하게 물리 - 논리 주소로 변환을 할까?  
그냥 물리 주소를 그대로 사용할 수는 없는건가?  

물리 주소를 그대로 사용하면 발생하는 문제는 아래와 같다

+ 메모리 충돌
    - 물리 주소를 그대로 사용하면
        ```
        RAM 상태:
        ┌──────────┬──────────┬──────────┬──────────┐
        │ 0x0000   │ 0x1000   │ 0x2000   │ 0x3000   │
        └──────────┴──────────┴──────────┴──────────┘

        프로그램 A 컴파일 시:
        "내 변수는 0x1000에 저장하겠어!"

        프로그램 B 컴파일 시:
        "내 변수도 0x1000에 저장하겠어!"   
        
        // 충돌 발생!
        ```
+ 프로그램을 특정 메모리 위치에 로드하고 싶을 때
    ```
    프로그램 A 컴파일: "난 0x1000부터 시작해"
    프로그램 B 컴파일: "난 0x5000부터 시작해"

    실행 시점의 RAM:
    ┌──────────┬──────────┬──────────┬──────────┐
    │ OS       │ ???      │ 프로그램C │ ???      │
    │ 0x0000   │ 0x1000   │ 0x5000   │ 0x8000   │
    └──────────┴──────────┴──────────┴──────────┘

    문제:
    - 0x1000 위치가 이미 사용 중이면? → 실행 불가!
    - 프로그램을 정확히 그 위치에 배치해야 함
    - 메모리 공간이 낭비됨 (빈 공간 활용 불가)
    ```
+ 보안 문제
    - 물리 주소에 직접 접근이 가능하면 다른 프로그램의 메모리에 접근하여 비밀번호와 같은 민감한 정보를 탈취할 수 있다  

그렇다면 논리 주소를 사용할 때의 강점은?

+ 프로그램의 독립성
    - 각 프로그램은 자기만의 가상 메모리 공간을 가진다
        + 메모리 보호
        + 다른 프로그램 B가 프로그램 A의 논리 주소에 접근하려고 하면 MMU가 차단
+ 유연한 메모리 관리
    - 물리 메모리 중간이 비어있더라도 논리 메모리에서는 연속된 메모리 공간처럼 다룰 수 있다
        + MMU가 자동으로 매핑해주므로

### 캐시 기억 장치
캐시는 CPU와 RAM 사이에 위치한 임시 저장소  
CPU가 자주 사용하는 데이터를 미리 준비해두는 곳

현대 CPU는 3단계의 캐시를 가진다

+ 캐시 계층 구조
    - 캐시는 빠를수록 제조 비용이 높고 저장용량은 작아짐
    - 속도와 용량 사이에서 균형을 맞추기 위해 계층 구조를 사용
    - CPU는 L1, L2, L3를 거쳐 메인 메모리에 접근한다
    - 먼저 L1 캐시에서 탐색 후 없으면 L2 > L3 > 주기억 장치 순으로 탐색
    - 하위 계층에서 찾은 데이터는 상위 캐시에 복사하여 재사용 효율을 높임
    ```
    레지스터 > L1 캐시 > L2 캐시 > L3 캐시 > 주기억 장치 > 보조기억 장치 순
    ```

메모리 접근 과정

```
1. CPU: "주소 0x1000의 데이터를 가져와!"

2. L1 캐시 확인:
   ├─ 있음 (Cache Hit) → 즉시 반환
   └─ 없음 (Cache Miss) → L2 캐시 확인
   
3. L2 캐시 확인:
   ├─ 있음 (Cache Hit) → 반환 + L1에 복사
   └─ 없음 (Cache Miss) → L3 캐시 확인
   
4. L3 캐시 확인:
   ├─ 있음 (Cache Hit) → 반환 + L2, L1에 복사
   └─ 없음 (Cache Miss) → RAM에서 가져옴
   
5. RAM에서 가져온 데이터는 모든 캐시에 복사됨
```

캐시가 효과적인 이유는 `지역성의 원리` 때문

+ 시간적 지역성
    - 최근에 사용한 데이터는 다시 사용될 가능성이 높다
    - 반복문에서 사용한 변수 i, count 등
+ 공간 지역성
    - 한번 접근한 주소 근처의 데이터도 곧 접근할 가능성이 높다
    - 배열을 순차적으로 탐색할 때


캐시 미스를 줄이기 위해 지역성을 적극 활용한다
