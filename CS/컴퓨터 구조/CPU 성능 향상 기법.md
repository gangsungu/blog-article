## CPU 성능 향상 기법

### 인터럽트
CPU가 현재 실행 중인 작업을 멈추고 중요한 이벤트를 처리한 후,  
원래의 프로그램으로 복귀하는 것

+ 인터럽트의 종류
    - 하드웨어 인터럽트
        + 외부 장치(하드웨어)에서 발생하는 인터럽트
        + 키보드 입력, 마우스 클릭, 네트워크 패킷 도착 등
    - 소프트웨어 인터럽트
        + 소프트웨어에서 발생하는 인터럽트
        + 시스템 호출 : 프로세스가 커널 서비스 요청
        + 예외 : Java에서 프로그램 오류가 발생할 때 등

그렇다면 인터럽트가 왜 필요한가?  

CPU가 모든 장치의 상태를 계속 확인(폴링)하면 시간과 리소스 낭비가 발생  
인터럽트로 인해 필요할 때만 CPU가 개입하므로 효율적인 동작이 가능

+ 인터럽트 처리 과정
    - 스택 : 기존 처리하던 작업 정보를 저장, 주기억 장치의 일부를 차지함
    - 인터럽트 벡터 : 각 인터럽트 요청에 대응하는 `인터럽트 서비스 루틴`의 주소를 저장
    - 인터럽트 서비스 루틴 : 특정 인터럽트를 처리하는 작업이 정의
    - 처리 과정
        + 인터럽트 요청 신호 발생
            - 하드웨어 장치(입출력 장치)에서 CPU에게 인터럽트 요청
        + 현재 상태 저장
            - CPU는 인터럽트 요청 신호를 받고 현재 상태(레지스터, PC)를 스택에 저장
        + 인터럽트 처리
            - CPU는 인터럽트를 처리하기 위해 인터럽트 벡터를 참조
            - 인터럽트 벡터에 맞는 인터럽트 서비스 루틴을 실행하여 인터럽트를 처리
        + 상태 복원
            - 인터럽트 처리 후 스택에 저장했던 작업 상태를 복원하고 중단되었던 작업을 재개

### 파이프라이닝
+ 명령어 파이프라이닝
    - 한번에 하나의 명령어만 실행하는게 아니라 동시에 여러 명령을 실행하는 기법
    - 각 명령어 처리 과정을 몇 단계로 분리하고 명령어를 실행하는 도중, 다음 명령어의 실행을 시작하여 성능을 향상
    - 파이프라이닝 단계별 소요시간 균형의 중요성
        + 파이프라인은 가장 느린 단계에 의해 제한
        + 균형잡힌 파이프라인
            ```
            클럭:  0ns   5ns   10ns  15ns  20ns  25ns
                    |     |     |     |     |     |
            명령1: IF  → ID  → EX  → MEM → WB
            명령2:       IF  → ID  → EX  → MEM → WB
            명령3:             IF  → ID  → EX  → MEM

            클럭 주기: 5ns
            처리량: 5ns마다 1개 명령어 완료
            ```
        + 불균형한 파이프라인
            ```
            IF:  2ns
            ID:  3ns
            EX:  10ns ← 병목!
            MEM: 4ns
            WB:  2ns

            클럭:  0ns   10ns  20ns  30ns  40ns  50ns
                    |     |     |     |     |     |
            명령1: IF  → ID  → EX  → MEM → WB
                2ns  3ns  10ns  4ns  2ns
                [idle][idle][----][idle][idle]
                
            명령2:       IF  → ID  → EX  → MEM → WB
                        [idle][idle][----][idle][idle]

            클럭 주기: 10ns (EX 단계에 맞춰야 함!)
            처리량: 10ns마다 1개 명령어 완료
            ```
            - 문제점
                + IF 단계 : 2ns만 사용하고 8ns 대기 (80% 유휴)
                + ID 단계: 3ns만 사용하고 7ns 대기 → 70% 유휴
                + MEM 단계: 4ns만 사용하고 6ns 대기 → 60% 유휴
                + WB 단계: 2ns만 사용하고 8ns 대기 → 80% 유휴

왜 가장 느린 단계에 맞춰야 하나?  
파이프라인 레지스터의 동작 원리를 알아보자  

+ 파이프라인 레지스터
    - 클럭 신호에 동기화되어 데이터 전달
    - 모든 단계가 동시에 다음 단계로 이동
    - 한 단계라도 완료되지 않으면 전체 대기

결론은 **가장 약한 고리가 전체 강도를 결정**한다

### 파이프라이닝 단계의 진화
파이프라이닝은 성능 요구사항에 따라 다양한 단계로 구현된다  
단계가 많을수록 각 단계가 단순해지고 클럭 속도를 높일 수 있지만 관리 복잡도와 해저드 처리 비용이 증가한다

+ 2단계 파이프라이닝
    |클럭 주기|1클럭|2클럭|3클럭|4클럭|
    |---|---|---|---|---|
    |명령어1|인출|실행|||
    |명령어2||인출|실행||
    |명령어3|||인출|실행|
    - 특징
        + 장점 : 구현이 간단, 제어로직 단순
        + 단점 : EX 단계가 너무 복잡하여 병목 발생 가능성 높음
+ 4단계 파이프라이닝
    |클럭 주기|1클럭|2클럭|3클럭|4클럭|5클럭|6클럭|7클럭|
    |---|---|---|---|---|---|---|---|
    |명령어1|명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행||||
    |명령어2||명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행|||
    |명령어3|||명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행||
    |명령어4||||명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행|
+ 6단계 파이프라이닝
    |클럭 주기|1클럭|2클럭|3클럭|4클럭|5클럭|6클럭|7클럭|8클럭|9클럭|
    |---|---|---|---|---|---|---|---|---|---|
    |명령어1|명령어 인출|명령어 해독|오퍼랜드 계산|오퍼랜드 인출|명령어 실행|오퍼랜드 저장||||
    |명령어2||명령어 인출|명령어 해독|오퍼랜드 계산|오퍼랜드 인출|명령어 실행|오퍼랜드 저장|||
    |명령어3|||명령어 인출|명령어 해독|오퍼랜드 계산|오퍼랜드 인출|명령어 실행|오퍼랜드 저장||
    |명령어4||||명령어 인출|명령어 해독|오퍼랜드 계산|오퍼랜드 인출|명령어 실행|오퍼랜드 저장|

결론적으로 파이프라이닝의 본질은

```
파이프라인 단계를 늘린다 
    ↓
각 단계가 더 단순해진다
    ↓
각 단계에 필요한 시간이 줄어든다
    ↓
클럭 주기를 짧게 설정할 수 있다
    ↓
클럭 속도(주파수)가 높아진다
    ↓
전체 처리량(Throughput) 향상
```

### 파이프라이닝의 한계와 해저드
이론적으로 k단계 파이프라이닝은 k배의 속도 향상을 기대하지만  
현실에서는 `명령어 간의 의존성, 자원 충돌, 분기 명령`등의 이유로 완벽하게 동작하지 않는 경우가 있다  
이것을 `파이프라이닝 해저드`라고 한다

+ 파이프라이닝 해저드
    - 명령어들이 동시에 실행될 때, 서로 간섭하여 파이프라인이 멈추거나 잘못된 명령이 실행되는 현상
    - 종류
        + 구조적 해저드
            - 여러 명령이 동시에 같은 하드웨어 자원을 사용하려 할 때 발생
            - 명령1과 명령2가 같은 메모리에 접근하려고 할때
            - 일부 명령이 자원 충돌로 인해 즉시 실행되지 못하고 지연

            |클럭 주기|1클럭|2클럭|3클럭|4클럭|5클럭|6클럭|7클럭|
            |---|---|---|---|---|---|---|---|
            |명령어1|명령어 인출|명령어 해독|명령어 실행|결과 저장||||
            |명령어2||명령어 인출|명령어 해독|명령어 실행|결과 저장|||
            |명령어3|||명령어 인출|명령어 해독|명령어 실행|메모리 접근|결과 저장|
            |명령어4||||명령어 인출|명령어 해독|명령어 실행|결과 저장|
            - 해결법
                + 하드웨어 자원을 복제
                + 한쪽 명령을 잠시 대기(stall)시켜 순차적으로 실행
        + 데이터 해저드
            - 이전 명령의 결과값이 준비되기 전에 다음 명령이 그 값을 사용하려고 할때 발생
            ```
            명령어 1: ADD R1, R2, R3    // R1 = R2 + R3
            명령어 2: SUB R4, R1, R5    // R4 = R1 - R5
                              ↑ R1을 읽어야 함

            클럭:  1    2    3    4    5    6
            ADD:  IF → ID → OF → EX → WB
                                ↓ R1 = 100
            SUB:       IF → ID → OF → EX → WB
                                ↑ 
                            R1을 읽어야 하는데
                            아직 준비 안됨!
            ```
            - 해결법
                + 대기 : 파이프라인이 한 사이클 정지하지만 안전하게 실행 가능
                + 데이터 전달 : 이전 명령의 결과를 레지스터에 저장하기 전에 바로 다음 명령에 전달하는 방식
                    - 데이터를 직접 전달하여 대기를 줄이는 기법
        + 제어 해저드
            - 분기나 JMP 명령어떄문에 다음 명령의 주소를 확정할 수 없을 때 발생
            ```
            주소  명령어
            1000: BEQ R1, R2, 2000   // R1 == R2이면 2000번지로 점프
            1004: ADD R3, R4, R5     // 다음 명령어
            1008: SUB R6, R7, R8
            ...
            2000: MUL R9, R10, R11   // 점프 목적지

            // 1004번지 명령어를 가져왔는데 2000번지로 이동해야 함
            // 이미 가져온 명령어를 버려야 함(Flush)
            // 3클럭 낭비 발생!
            ```
            - 해결법
                + 대기 : 매우 비효율적
                + 분기 예측 : 다음 명령을 미리 예상하여 인출하는 방식
                + 지연 분기 : 분기 명령 직후의 한두 클럭을 조건과 상관없이 먼저 실행
                    - 조건이 틀리면? Flush 후 다시 실행!

### 슈퍼스칼라 프로세서
슈퍼스칼라 프로세서는 파이프라이닝 기법에 병렬 처리를 지원하는 방법  

한번에 n개의 명령어를 병렬 처리할 수 있는 n등급의 슈퍼스칼라 프로세서는  
이론적으로 파이프라이닝 기법에 비해 n배의 성능향상을 기대할 수 있음

|클럭 주기|1클럭|2클럭|3클럭|4클럭|5클럭|6클럭|7클럭|
|---|---|---|---|---|---|---|---|
|명령어1|명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행||||
|명령어2|명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행||||
|명령어3||명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행|||
|명령어4||명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행|||
|명령어5|||명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행||
|명령어6|||명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행||
|명령어7||||명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행|
|명령어8||||명령어 인출|명령어 해독|오퍼랜드 인출|명령어 실행|

### 슈퍼 파이프라이닝
파이프라인을 더 잘게 쪼개서 클럭 속도를 높이는 기법

+ 장점
    - 높은 클럭 속도
        + 단계가 짧다 > 클럭이 빠르다 (이론적으로 2배의 속도 향상을 기대)
    - 처리량 향상
        + 더 자주 명령어를 완료
        + CPI는 비슷하지만 클럭이 빠름
+ 단점
    - 해저드 영향 증가
        + 분기 예측이 실패할 때, 일반 파이프라인이 5단계 flush가 발생한다면 슈퍼 파이프라인은 10단계의 flush 발생!