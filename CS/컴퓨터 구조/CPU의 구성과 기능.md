## CPU의 구성과 기능

### 중앙 처리 장지 (CPU)
프로그램 명령을 해석하고 실행하는 역할, 사람의 두뇌에 해당  
아래 3가지 요소가 협력하여 명령어를 실행

+ 연산장치
    - 산술논리 연산 장치 (ALU)
    - 사칙연산과 논리연산을 담당
+ 제어장치
    - 명령어를 해독하는 기능, 제어 신호를 해당 장치에 전달하는 역할
    - CPU 내부와 다른 하드웨어 장치 간의 데이터 흐름 관리
+ 레지스터
    - CPU 내부의 가장 빠른 저장 공간
    - CPU가 즉시 사용해야 하는 데이터나 명령어를 임시로 저장한다
    - 프로그램 카운터 (Program Counter)
        + 다음에 실행할 명령어의 메모리 주소를 저장
        + CPU가 명령어를 하나 실행할 때마다 자동으로 증가

### 컨텍스트 스위칭과 레지스터
프로세스가 전환될 때, 다음 과정에서 오버헤드가 발생하므로  
불필요한 컨텍스트 스위칭을 줄이는 것이 중요하다

+ 현재 프로세스의 모든 레지스터 값을 메모리(PCB)에 저장
+ 새 프로세스의 레지스터 값을 복원
+ 실행 재개

### PCB (Process Control Block)
운영체제가 프로세스를 관리하기 위해 필요한 모든 정보를 담고 있는 자료구조  

쉽게 비유하면  
프로세스 = 실행 중인 프로그램 / PCB = 프로세스의 신분증  

PCB는 운영체제의 커널 메모리 영역에 저장되며 메모리 구조를 간략화하면 다음과 같다
```
[메모리 구조]

커널 영역 (Kernel Space)
├── PCB #1 (Chrome)
├── PCB #2 (IntelliJ)
├── PCB #3 (Spring Boot App)
└── ...
─────────────────────
사용자 영역 (User Space)
├── 프로세스 #1의 코드/데이터/스택
├── 프로세스 #2의 코드/데이터/스택
└── ...
```

프로세스 A에서 프로세스 B로 전환될 때, 컨텍스트 스위칭 과정을 보면
```
[1단계: 프로세스 A의 상태 저장]
CPU 레지스터 → PCB_A에 저장
├── RAX, RBX, RCX, RDX ...
├── PC (다음 실행할 명령어 주소)
├── SP (스택 포인터)
└── Flags (상태 플래그)

[2단계: 프로세스 B의 상태 복원]
PCB_B에서 → CPU 레지스터로 복원
├── RAX, RBX, RCX, RDX ...
├── PC 
├── SP
└── Flags

[3단계: 실행 재개]
프로세스 B가 멈췄던 지점부터 계속 실행
```

### TLB (Translation Lookaside Buffer)
현대 운영체제는 프로세스에게 `가상 주소`를 사용하도록 하고 실제 물리 메모리는 `물리 주소`로 관리한다  
이렇게 사용하는 이유는 무엇일까?  

+ 가상 메모리의 장점
    - 프로세스 격리
        + 각 프로세스는 독립된 주소 공간을 가짐
        + 프로세스 A가 프로세스 B의 메모리를 침범할 수 없음
    - 메모리 효율성
        + 실제 물리 메모리보다 큰 주소 공간 사용 가능
        + 자주 사용하지 않는 데이터는 디스크(swap)으로 이동
    - 메모리 단편화 해결
        + 가상 메모리는 연속적이지만, 물리 메모리는 비연속적으로 할당 가능

이제 TLB의 등장 배경에 대해 알아보자

```java
// Java에서 객체를 생성하면
String str = new String("Hello");

// JVM은 가상 주소를 받음 (예: 0x7fff1234)
// 실제 물리 메모리는 전혀 다른 곳 (예: 0x8abc5678)
```

객체를 사용하려면 가상 주소를 물리 주소로 변환이 필요하다  
변환 과정은 가상 주소 -> Page Table -> 물리 주소의 과정을 거친다  
여기서 Page Table은 가상 주소와 물리 주소의 매핑 정보를 담은 테이블인데, 여기서 문제가 발생한다  

메모리에 접근할 때마다 Page Table을 조회해야 하는데, Page Table 자체도 메모리에 있으므로  

```
[일반적인 메모리 접근]
1. Page Table 읽기 (메모리 접근 1회) ← 100ns
2. 실제 데이터 읽기 (메모리 접근 1회) ← 100ns
────────────────────────────────────────
총 200ns! (2배 느림!)
```

TLB는 이러한 문제를 해결하기 위해 등장한 `하드웨어 캐시`

+ Page Table의 일부를 캐싱하는 작은 캐시
+ CPU 내부에 위치 (MMU : Memory Management Unit)
+ 매우 빠름 (메모리의 1/100)
+ 크기는 작다
+ TLB의 구조 (엔트리 단위)
    ```
    [TLB Entry]
    ┌─────────────────┬─────────────────┬──────┬──────┐
    │ 가상 페이지 번호 │ 물리 페이지 번호 │ Valid│ Dirty│
    ├─────────────────┼─────────────────┼──────┼──────┤
    │      0x1000     │      0x5000     │  1   │  0   │
    │      0x2000     │      0x7000     │  1   │  1   │
    │      0x3000     │      0x2000     │  1   │  0   │
    └─────────────────┴─────────────────┴──────┴──────┘
    ```

### TLB를 활용한 주소 변환 과정
```
[메모리 접근 요청]
가상 주소: 0x1234
    ↓
[1단계: TLB 확인]
TLB에 0x1000 있나? → YES! (TLB Hit)
    ↓
물리 주소: 0x5234
    ↓
[2단계: 메모리 접근]
실제 데이터 읽기
────────────────
총 소요 시간: ~101ns (1ns TLB + 100ns 메모리)
```

하지만 만약 TBL가 Miss라면?

```
[1단계: TLB 확인]
TLB에 없음! (TLB Miss)
    ↓
[2단계: Page Table 조회]
메모리에서 Page Table 읽기 (100ns)
    ↓
[3단계: TLB 업데이트]
찾은 매핑 정보를 TLB에 저장
    ↓
[4단계: 메모리 접근]
실제 데이터 읽기 (100ns)
────────────────
총 소요 시간: ~200ns
```

TLB Miss가 발생하면 소요시간이 훌쩍 늘어난다  
그래서 TLB Hit Rate가 중요해진다

```
TLB Hit Rate = (TLB Hit 횟수) / (전체 메모리 접근 횟수)
```

### 컨텍스트 스위칭과 TLB의 관계
```
[프로세스 A 실행 중]
TLB에는 프로세스 A의 주소 매핑 정보가 캐싱됨
┌─────────────────┬─────────────────┐
│ A의 가상 주소    │ A의 물리 주소    │
├─────────────────┼─────────────────┤
│   0x1000        │   0x5000        │
│   0x2000        │   0x7000        │
└─────────────────┴─────────────────┘

[Context Switch 발생!]
프로세스 A > 프로세스 B

[문제 발생!]
프로세스 B가 가상 주소 0x1000에 접근
TLB에는 프로세스 A의 0x1000 → 0x5000 매핑이 있음
하지만 프로세스 B의 0x1000은 전혀 다른 물리 주소여야 함!
> 잘못된 메모리 접근!

[해결 방법]
Context Switch 시 TLB를 비운다 (Flush)
또는 ASID(Address Space ID)를 사용해 구분

[TLB Flush의 비용]
1. TLB의 모든 엔트리를 무효화
2. 프로세스 B 실행 시작
3. 처음에는 모든 메모리 접근이 TLB Miss
4. 점차 TLB가 채워지며 성능 회복
```
> 컨텍스트 스위칭이 비싼 이유!

### 명령어의 처리 흐름
명령어는 CPU가 실행하는 한줄의 `기계어 코드`  

```
예시:
ADD R1, R2, R3   // R1 = R2 + R3
LOAD R1, [100]   // 메모리 주소 100의 값을 R1에 로드
STORE R1, [200]  // R1의 값을 메모리 주소 200에 저장
```

+ 명령어 사이클
    - CPU가 명령어 하나를 실행하는 과정을 `명령어 사이클`이라고 한다
    - 인출 (Fetch) : 명령어 가져오기
        + 프로그램 카운터가 가리키는 메모리 주소에서 명령어를 가져와 레지스터에 저장
            ```
            [메모리]                    [CPU]
            주소 100: ADD R1,R2,R3  →  IR: ADD R1,R2,R3
                    ↑                  PC: 100
                    PC가 가리킴         
                                    PC = PC + 4 (다음 명령어로)
            ```
    - 해석 (Decode) : 명령어 해석하기
        + 명령어를 해석하여 작업내용 파악
        + 필요한 데이터를 레지스터에서 읽고 R2와 R3의 값을 준비
            ```
            ADD R1, R2, R3
            ↓   ↓   ↓   ↓
            연산 목적 피연산자1 피연산자2

            제어 장치(Control Unit)가 판단:
            - 연산 종류: 덧셈
            - 필요한 레지스터: R1(목적지), R2, R3(소스)
            - 필요한 연산 유닛: ALU (산술논리연산장치)
            ```
    - 실행 (Execute) : 명령어 실행하기
        + 실제 연산 수행
            ```
            예시: ADD R1, R2, R3
            R2 = 5
            R3 = 10

            ALU에서 계산:
            5 + 10 = 15
            ```
    - 메모리 접근
        + 메모리 읽기/쓰기가 필요한 경우에 사용
            ```
            LOAD R1, [100]  → 메모리 100번지 읽기
            STORE R1, [200] → 메모리 200번지 쓰기
            ```
    - 결과 저장
        + 연산 결과를 레지스터에 저장
            ```
            ADD R1, R2, R3의 경우:
            계산 결과 15를 R1에 저장
            ```

하나의 명령어 사이클이 끝나면 다음 명령어의 주소를 프로그램 카운터에서 가져와야 한다  
그렇다면 명령어 사이클이 끝나 결과를 저장하고 가져오나 생각할 수도 있지만  
프로그램 카운터는 인출 과정에서 업데이트가 진행된다

```
1. PC가 가리키는 주소에서 명령어 읽기 (Fetch)
2. PC = PC + 4 (즉시 다음 주소로 업데이트!)
   ↑
   명령어가 끝나기 전에 이미 업데이트됨!
3. 명령어 해석 (Decode)
4. 명령어 실행 (Execute)
5. ...
```

그렇다면 왜 인출 즉시 업데이트를 진행할까?  

+ 파이프라이닝
    - 명령어가 끝날 때까지 대기하면 다음 명령어를 가져올 수 없다
        ```
        시간:  1  2  3  4  5
        명령1: IF ID EX ME WB
        명령2:    IF ID EX ME WB  ← IF는 사이클 2에 시작!
                ↑
            이때 PC가 이미 104를 가리켜야 함
        ```  

단, 분기 명령어는 예외!  
PC값이 바뀌기 때문에 미리 가져올 수 없다

```
주소 100: BEQ R1, R2, 200  // R1==R2이면 200으로 점프
주소 104: ADD R3, R4, R5
...
주소 200: SUB R6, R7, R8

경우 1: R1 == R2 (분기 성공)
- IF: PC=100, 명령어 읽기
- PC→104 (일단 증가)
- EX: 조건 확인 → 참!
- PC→200 (덮어쓰기!) ← 여기가 다름!
- 다음 IF: 메모리[200] 읽기

경우 2: R1 != R2 (분기 실패)
- IF: PC=100, 명령어 읽기
- PC→104 (증가)
- EX: 조건 확인 → 거짓
- PC 유지 (104 그대로)
- 다음 IF: 메모리[104] 읽기
```