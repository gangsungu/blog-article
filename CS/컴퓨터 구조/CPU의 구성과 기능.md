## CPU의 구성과 기능

### 중앙 처리 장지 (CPU)
프로그램 명령을 해석하고 실행하는 역할, 사람의 두뇌에 해당  
아래 3가지 요소가 협력하여 명령어를 실행

+ 연산장치
    - 산술논리 연산 장치 (계산기)
    - 사칙연산과 논리연산을 담당
+ 제어장치
    - 명령어를 해독하는 기능, 제어 신호를 해당 장치에 전달하는 역할
    - CPU 내부와 다른 하드웨어 장치 간의 데이터 흐름 관리
+ 레지스터
    - CPU 내부의 가장 빠른 저장 공간
    - CPU가 즉시 사용해야 하는 데이터나 명령어를 임시로 저장한다
    - 프로그램 카운터 (Program Counter)
        + 다음에 실행할 명령어의 메모리 주소를 저장
        + CPU가 명령어를 하나 실행할 때마다 자동으로 증가

### 컨텍스트 스위칭과 레지스터
프로세스가 전환될 때, 다음 과정에서 오버헤드가 발생하므로  
불필요한 컨텍스트 스위칭을 줄이는 것이 중요하다

+ 현재 프로세스의 모든 레지스터 값을 메모리(PCB)에 저장
+ 새 프로세스의 레지스터 값을 복원
+ 실행 재개

### PCB (Process Control Block)
운영체제가 프로세스를 관리하기 위해 필요한 모든 정보를 담고 있는 자료구조  

쉽게 비유하면  
프로세스 = 실행 중인 프로그램 / PCB = 프로세스의 신분증  

PCB는 운영체제의 커널 메모리 영역에 저장되며 메모리 구조를 간략화하면 다음과 같다
```
[메모리 구조]

커널 영역 (Kernel Space)
├── PCB #1 (Chrome)
├── PCB #2 (IntelliJ)
├── PCB #3 (Spring Boot App)
└── ...
─────────────────────
사용자 영역 (User Space)
├── 프로세스 #1의 코드/데이터/스택
├── 프로세스 #2의 코드/데이터/스택
└── ...
```

프로세스 A에서 프로세스 B로 전환될 때, 컨텍스트 스위칭 과정을 보면
```
[1단계: 프로세스 A의 상태 저장]
CPU 레지스터 → PCB_A에 저장
├── RAX, RBX, RCX, RDX ...
├── PC (다음 실행할 명령어 주소)
├── SP (스택 포인터)
└── Flags (상태 플래그)

[2단계: 프로세스 B의 상태 복원]
PCB_B에서 → CPU 레지스터로 복원
├── RAX, RBX, RCX, RDX ...
├── PC 
├── SP
└── Flags

[3단계: 실행 재개]
프로세스 B가 멈췄던 지점부터 계속 실행
```

### TLB (Translation Lookaside Buffer)
현대 운영체제는 프로세스에게 `가상 주소`를 사용하도록 하고 실제 물리 메모리는 `물리 주소`로 관리한다  
이렇게 사용하는 이유는 무엇일까?  

+ 가상 메모리의 장점
    - 프로세스 격리
        + 각 프로세스는 독립된 주소 공간을 가짐
        + 프로세스 A가 프로세스 B의 메모리를 침범할 수 없음
    - 메모리 효율성
        + 실제 물리 메모리보다 큰 주소 공간 사용 가능
        + 자주 사용하지 않는 데이터는 디스크(swap)으로 이동
    - 메모리 단편화 해결
        + 가상 메모리는 연속적이지만, 물리 메모리는 비연속적으로 할당 가능

이제 TLB의 등장 배경에 대해 알아보자

```java
// Java에서 객체를 생성하면
String str = new String("Hello");

// JVM은 가상 주소를 받음 (예: 0x7fff1234)
// 실제 물리 메모리는 전혀 다른 곳 (예: 0x8abc5678)
```

객체를 사용하려면 가상 주소를 물리 주소로 변환이 필요하다  
변환 과정은 가상 주소 -> Page Table -> 물리 주소의 과정을 거친다  
여기서 Page Table은 가상 주소와 물리 주소의 매핑 정보를 담은 테이블인데, 여기서 문제가 발생한다  

메모리에 접근할 때마다 Page Table을 조회해야 하는데, Page Table 자체도 메모리에 있으므로  

```
[일반적인 메모리 접근]
1. Page Table 읽기 (메모리 접근 1회) ← 100ns
2. 실제 데이터 읽기 (메모리 접근 1회) ← 100ns
────────────────────────────────────────
총 200ns! (2배 느림!)
```

TLB는 이러한 문제를 해결하기 위해 등장한 `하드웨어 캐시`

+ Page Table의 일부를 캐싱하는 작은 캐시
+ CPU 내부에 위치 (MMU : Memory Management Unit)
+ 매우 빠름 (메모리의 1/100)
+ 크기는 작다
+ TLB의 구조 (엔트리 단위)
    ```
    [TLB Entry]
    ┌─────────────────┬─────────────────┬──────┬──────┐
    │ 가상 페이지 번호 │ 물리 페이지 번호 │ Valid│ Dirty│
    ├─────────────────┼─────────────────┼──────┼──────┤
    │      0x1000     │      0x5000     │  1   │  0   │
    │      0x2000     │      0x7000     │  1   │  1   │
    │      0x3000     │      0x2000     │  1   │  0   │
    └─────────────────┴─────────────────┴──────┴──────┘
    ```

### TLB를 활용한 주소 변환 과정
```
[메모리 접근 요청]
가상 주소: 0x1234
    ↓
[1단계: TLB 확인]
TLB에 0x1000 있나? → YES! (TLB Hit)
    ↓
물리 주소: 0x5234
    ↓
[2단계: 메모리 접근]
실제 데이터 읽기
────────────────
총 소요 시간: ~101ns (1ns TLB + 100ns 메모리)
```

하지만 만약 TBL가 Miss라면?

```
[1단계: TLB 확인]
TLB에 없음! (TLB Miss)
    ↓
[2단계: Page Table 조회]
메모리에서 Page Table 읽기 (100ns)
    ↓
[3단계: TLB 업데이트]
찾은 매핑 정보를 TLB에 저장
    ↓
[4단계: 메모리 접근]
실제 데이터 읽기 (100ns)
────────────────
총 소요 시간: ~200ns
```

TLB Miss가 발생하면 소요시간이 훌쩍 늘어난다  
그래서 TLB Hit Rate가 중요해진다

```
TLB Hit Rate = (TLB Hit 횟수) / (전체 메모리 접근 횟수)
```

### 컨텍스트 스위칭과 TLB의 관계
```
[프로세스 A 실행 중]
TLB에는 프로세스 A의 주소 매핑 정보가 캐싱됨
┌─────────────────┬─────────────────┐
│ A의 가상 주소    │ A의 물리 주소    │
├─────────────────┼─────────────────┤
│   0x1000        │   0x5000        │
│   0x2000        │   0x7000        │
└─────────────────┴─────────────────┘

[Context Switch 발생!]
프로세스 A > 프로세스 B

[문제 발생!]
프로세스 B가 가상 주소 0x1000에 접근
TLB에는 프로세스 A의 0x1000 → 0x5000 매핑이 있음
하지만 프로세스 B의 0x1000은 전혀 다른 물리 주소여야 함!
> 잘못된 메모리 접근!

[해결 방법]
Context Switch 시 TLB를 비운다 (Flush)
또는 ASID(Address Space ID)를 사용해 구분

[TLB Flush의 비용]
1. TLB의 모든 엔트리를 무효화
2. 프로세스 B 실행 시작
3. 처음에는 모든 메모리 접근이 TLB Miss
4. 점차 TLB가 채워지며 성능 회복
```
> 컨텍스트 스위칭이 비싼 이유!