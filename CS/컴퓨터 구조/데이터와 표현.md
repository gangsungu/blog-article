## 데이터와 표현

### 비트와 바이트
+ 컴퓨터는 10진법이 아닌 2진법을 사용해 정보를 저장한다
    - 0과 1만을 사용
    - 전기신호의 전압이 일정 기준보다 높으면 1, 그렇지 않으면 0으로 변환

+ 비트 (bit)
    - 0과 1을 표현할 수 있는 최소 단위
    - 여러 개의 비트를 조합하여 데이터를 표현
        + 3개의 비트가 있으면 2 * 2 * 2 = 8, 총 8개의 표현이 가능 (2<sup>n</sup>개의 표현이 가능)
+ 바이트 (byte)
    - 8비트를 한 묶음으로 표현한 단위
        + 1바이트당 256(2<sup>8</sup>)가지의 데이터 표현이 가능

### 컴퓨터의 숫자 표현 (정수)
+ 음수의 표현
    - 부호 비트
        + 컴퓨터는 n비트에서 가장 왼쪽의 비트(최상위 비트)를 부호 비트로 사용하여 음수를 표현
        + 부호 비트가 1이면 음수, 0이면 양수
    - 2의 보수
        + 음수를 저장하기 위해 사용하는 방법
        + 모든 비트를 반전시키고 1을 더한다
        + n개의 비트로 표현할 수 있는 정수의 범위는 -2<sup>(n-1)</sup> ~ 2<sup>(n-1)</sup>-1
            - 즉 n=4일 때, 표현가능한 정수의 범위는 -8 ~ 7

    |4비트 표현조합|10진수|4비트 표현조합|10진수|
    |---|---|---|---|
    |0000|0|1000|-8|
    |0001|1|1001|-7|
    |0010|2|1010|-6|
    |0011|3|1011|-5|
    |0100|4|1100|-4|
    |0101|5|1101|-3|
    |0110|6|1110|-2|
    |0111|7|1111|-1|

    - singed와 unsigned
        + `1010` 비트 패턴이라도 어떻게 해석하느냐에 따라 다른 값이 된다
        + signed (부호있는 정수)
            - 2의 보수 사용
            ```
            1010
            ↑
            이 비트가 1이면 음수!

            1010 = -6 (2의 보수 방식)
            ```
        + unsigned (부호없는 정수)
            - 2의 보수 사용하지 않음
            ```
            1010 = 1×8 + 0×4 + 1×2 + 0×1 = 10
            ```

            |언어|기본값|unsigned 지원|signed 명시|
            |---|---|---|---|
            |Java|signed|❌ 없음|불필요 (항상 signed)|
            |C<sup>++</sup>|signed|✅ 있음|선택가능|

### 컴퓨터의 숫자 표현 (실수)
+ 부동소수점 (Floating Point)
    - 컴퓨터가 실수(소수)를 표현하는 방법
    - 소수점의 위치가 고정되지 않고 움직인다는 의미
    - 정수만으로 표현하지 못하는 값을 표현하기 위해 사용

    ```
    3.14 (원주율)
    0.5 (반)
    -273.15 (절대영도)
    0.0000001 (아주 작은 수)
    1000000000000.0 (아주 큰 수)
    ```

    - IEEE754 표준 (부동소수점 표준)
        + 현대 컴퓨터에서 부동소수점을 표현하기 위해 사용하는 국제 표준
        + 구조
            - 부호 (Sign) 1비트 | 지수(Exponent) 8비트 | 가수(Mantissa) 23비트
            - 부호 비트 : 숫자의 양수, 음수 (방향)을 결정
            - 지수 비트 : 숫자의 스케일 (범위)를 결정
        + 공식
            - (-1)^부호 × 가수 × 2^지수
        + 소수 부분 이진 변환 규칙
            - 소수에 2를 곱하기
            - 결과의 정수를 기록 (0 또는 1)
            - 결과의 소수만 남기고 소수 부분이 0이 될때까지 반복
                + 예시1 : 0.5
                    ```
                    0.5 × 2 = 1.0
                            ↑ ↑
                        정수:1 소수:0

                    소수 부분이 0 → 종료!
                    0.5₁₀ = 0.1₂ ✅
                    ```
                + 예시2 : 0.25
                    ```
                    0.25 × 2 = 0.5  → 정수: 0, 소수: 0.5
                    0.5  × 2 = 1.0  → 정수: 1, 소수: 0.0

                    소수 부분이 0 → 종료!

                    0.25₁₀ = 0.01₂ ✅
                    ```
            - 왜 이 방법이 맞을까? 수학적으로 검증해보면
                ```
                0.1₂ = 1 × 2⁻¹ = 1 × 1/2 = 0.5₁₀ ✅
                0.01₂ = 1 × 2⁻² = 1 × 1/4 = 0.25₁₀ ✅
                0.11₂ = 1 × 2⁻¹ + 1 × 2⁻² = 0.5 + 0.25 = 0.75₁₀ ✅
                ```
    - 부동소수점의 한계
        + 오차
            - 실수는 2진수로 정확히 표현되지 않기 때문에 컴퓨터는 근사값으로 저장
                ```java
                double a = 0.1;
                double b = 0.2;
                double c = a + b;

                System.out.println(c);  // 0.30000000000000004 ← 어?!
                System.out.println(c == 0.3);  // false!
                ```
                + 0.1을 이진수로 정확히 표현할 수 없다! (무한소수의 문제)
                    ```
                    0.1 × 2 = 0.2  → 정수: 0, 소수: 0.2
                    0.2 × 2 = 0.4  → 정수: 0, 소수: 0.4
                    0.4 × 2 = 0.8  → 정수: 0, 소수: 0.8
                    0.8 × 2 = 1.6  → 정수: 1, 소수: 0.6
                    0.6 × 2 = 1.2  → 정수: 1, 소수: 0.2 ← 반복 시작!
                    0.2 × 2 = 0.4  → 정수: 0, 소수: 0.4
                    ...

                    0.1₁₀ = 0.0001100110011...₂ (무한 반복!)

                    // 따라서 0.1 + 0.2가 0.3이 아니다
                    // 유한한 비트로는 무한 반복되는 변환된 값을 저장할 수 없어 근사값이 저장됨
                    ```
                + 2의 거듭제곱 분수만 정확히 표현 가능하다
        + 정밀도가 필요한 경우
            - Decimal 사용
                + 실수를 10진 가수와 10진 지수 형태로 저장함
                    - 0.2 > 2 * 10<sup>-1</sup>
                    - 10진수 기반의 부동소수점이라고 볼 수 있다
                + 내부적으로 큰 정수값과 소수 자릿수를 함께 보관
                ```java
                BigDecimal a = new BigDecimal("0.1");
                BigDecimal b = new BigDecimal("0.2");
                BigDecimal c = a.add(b);

                // 0.3 정확하게 출력
                // 숫자를 문자열로 넘기는 이유는 숫자로 넘기면 부동소수점의 오차가 전파됨
                ```
            - 고정소수점 방식 (Fixed-point)
                + 실수를 정수로 변환하여 저장하고 소수점 위치는 고정
                + 모든 값이 동일한 자릿수를 따르므로 빠른 연산이 가능
                + 곱셈/나눗셈 진행할 때 스케일 보정이 필요
    - 부동소수점에서 음수 표현하기
        + 부동소수점에서 지수는 양수와 음수 모두 필요하다
            ```
            큰 수: 1.5 × 2⁸    → 지수: +8
            작은 수: 1.5 × 2⁻⁸  → 지수: -8
            ```
            - 하지만 지수를 저장할 8비트는 unsigned 방식, 그렇다면 음수를 어떻게 표현할까?
        + 127을 더해서 음수를 양수로 저장
            - 32비트 float의 경우
                ```
                실제 지수 범위: -126 ~ +127
                저장된 지수 범위: 1 ~ 254

                공식: 저장된 지수 = 실제 지수 + 127

                예시:
                실제 지수 +3  → 저장: 3 + 127 = 130
                실제 지수  0  → 저장: 0 + 127 = 127
                실제 지수 -3  → 저장: -3 + 127 = 124
                ```
        + 그렇다면 왜 127일까?
            - 8비트가 표현할 수 있는 범위는 0 ~ 255
            - 0은 0을 의미, 255는 특수값 따라서 실제 사용가능한 숫자는 1 ~ 254로 총 254개
            - 중간값: (1 + 254) / 2 ≈ 127.5 → 127

        ```
        비트: 0 10000010 10010000000000000000000

        1. 부호: 0 → 양수
        2. 지수: 10000010₂ = 130₁₀
        실제 지수: 130 - 127 = 3
        3. 가수: 10010000000000000000000
        실제 가수: 1.1001 (앞에 1 추가)

        값 = (+1) × 1.1001₂ × 2³
        = 1.1001₂ × 2³
        = 11001₂ (소수점 오른쪽으로 3칸)
        = 1100.1₂
        = 12.5₁₀ ✅
        ```

        + 왜 지수 비트에서 signed 방식을 사용하지 않을까?
            - 2의 보수를 사용한다면?
                ```
                8비트 signed: -128 ~ 127

                문제점:
                - 지수 비교가 복잡해짐
                - 큰 수인지 작은 수인지 판단 어려움

                예:
                11111111 (2의 보수 -1)
                01111111 (2의 보수 +127)

                비트 패턴으로 봤을 때:
                11111111 > 01111111 (unsigned 비교)
                하지만 실제 값은: -1 < 127
                ```
            - bias 방식을 사용한다면
                ```
                실제 지수 -3 → 저장: 124 (01111100)
                실제 지수 +3 → 저장: 130 (10000010)

                비트 패턴: 01111100 < 10000010
                실제 값:   -3 < 3 ✅

                부호 없는 정수로 비교해도 순서가 맞음!
                ```

### 컴퓨터의 문자 표현
+ 아스키 코드
    - 128개의 문자 조합을 제공하는 7비트 부호
    - 오류 검출을 위한 `패리티 부호`에 해당하는 1비트를 포함하여 총 8비트로 구성
        ```
        // 짝수 패리티 부호
        원본 데이터: 1011001 (1이 4개 - 짝수)
        패리티 비트: 0 (전체 1의 개수를 짝수로 만들기)
        전송 데이터: 10110010

        원본 데이터: 1011000 (1이 3개 - 홀수)
        패리티 비트: 1 (전체 1의 개수를 짝수로 만들기)
        전송 데이터: 10110001

        // 홀수 패리티 부호
        원본 데이터: 1011001 (1이 4개 - 짝수)
        패리티 비트: 1 (전체 1의 개수를 홀수로 만들기)
        전송 데이터: 10110011
        ```
    - 패리티 부호는 1개의 비트 오류는 검지가 가능하지만 2개의 비트 오류는 감지하지 못한다
+ 유니코드
    - 아스키 코드는 미국 표준이라 한국어, 일본어 등 외국어를 표현하는데 한계가 존재
    - 1995년 유니코드가 국제 표준으로 제정
    - 표현방법
        + 비트를 4개씩 나눠 16진법(4비트)로 표현
+ UTF-8
    - 유니코드를 저장하는 방법 중 하나
    - 8은 8비트를 기본 단위로 사용한다는 뜻
    - 특징
        + 가변 길이 인코딩이 가능 : 문자에 따라 1~4 바이트 사용
        + ASCII와 호환성 : 영문자는 ASCII와 동일
    - 인코딩 규칙
        + 0으로 시작 : 1바이트 문자 (ASCII)
        + 110으로 시작 : 2바이트 문자

        |바이트 수|코드 포인트 범위|바이트 패턴|
        |---|---|---|
        |1바이트|U+0000 ~ U+007F (128개)| 0xxxxxxx|
        |2바이트|U+0080 ~ U+07FF (1,920개)| 110xxxxx 10xxxxxx|
        |3바이트|U+0800 ~ U+FFFF (61,440개)| 1110xxxx 10xxxxxx 10xxxxxx|
        |4바이트|U+10000 ~ U+10FFFF| 11110xxx 10xxxxxx 10xxxxxx 10xxxxxx|
    - 인코딩 예제
        ```
        1. 코드 포인트: U+0041 = 0000 0000 0100 0001 (2진수)

        2. 범위 확인: U+0000 ~ U+007F → 1바이트 사용

        3. 패턴 적용: 0xxxxxxx
        하위 7비트만 사용: 100 0001
        
        4. 최종 결과: 0100 0001 = 0x41

        UTF-8: 0x41 (1바이트)
        ```