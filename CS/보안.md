## 보안

### 인증과 인가
+ 인증 (Authentication)
    - 사용자가 누구인지 확인하는 과정
+ 인가 (Authorization)
    - 사용자에게 자원에 접근할 수 있는 권한을 부여하는 것  

아이디와 암호를 입력하는 로그인은 인증의 한 형태  
사용자가 누구인지 확인하면 서버는 클라이언트에 문자열로 된 토큰을 제공하고 클라이언트는 각 요청마다 해당 토큰으로 자신을 증명한다  
그래서 매번 아이디와 비밀번호를 입력받지 않고 사용자를 식별할 수 있다  

이렇게 토큰을 사용해서 사용자를 식별하려면 매핑 정보를 저장해야 한다  
매핑 정보를 저장하는 곳은 크게 2가지가 있다

+ 서버의 별도 저장소
    - 서버의 DB나 레디스와 같은 외부 저장소
        + 로그인에 성공한 경우, 서버는 임의의 토큰 문자열을 생성한 후 매핑 정보를 저장
        + 토큰 문자열을 생성할 때는 고유한 값을 생성해서 토큰 중복이 일어나지 않도록 해야한다
    - 서버 메모리
        + 서블릿 세션
        + 톰캣과 같은 서블릿 컨테이너는 메모리에 세션 객체를 저장 (서블릿 세션은 고유의 ID를 생성)
        + 메모리에 세션 객체를 저장할 때는 고정 세션을 사용해야 한다
        + 단점
            - 서버를 재시작하면 메모리에 저장한 토큰 데이터가 사라짐
            - 생성할 수 있는 세션의 수가 메모리에 제한을 받음
+ 토큰
    - 대표적으로 JWT (JSON Web Token)
    - 장점
        + 토큰만 있으면 사용자가 누구인지 식별 가능
        + 별도의 외부DB에 토큰을 저장할 필요가 없으므로 서버 구조가 간단해진다
        + 메모리에 토큰을 저장하지 않으므로 서버를 수평으로 확장하기 쉬워진다
    - 단점
        + 네트워크 트래픽의 증가 (토큰 안에 데이터가 추가되므로)
        + 토큰을 서버에서 제어할 수 없다
            - 유효시간을 설정하여 해결
                + 토큰 생성 시간을 기준
                + 마지막 접근 시간을 기준

인증과 토큰은 사용자가 누구인지, 정상적으로 접근하는지 확인한다면  
인가는 사용자가 요청한 기능을 실행할 권한이 있는지 확인하는 역할을 한다  

+ RBAC (Role Based Access Control)
    - 역할 기반 접근 제어
    - 사용자에게 직접 권한을 주는게 아닌 역할을 통해 간접적으로 권한을 부여하는 방식

### 데이터 암호화
+ 단방향 암호화
    - 암호화한 데이터를 복호화할 수 없는 암호화 방식
    - 해시함수를 사용해서 데이터를 해시 값으로 변환
        + 대표적인 단방향 암호화 알고리즘에는 SHA-256, MD5, Bcrypt
        + 해시 함수 알고리즘은 원본 데이터를 유추하기 어렵도록 원본 데이터마다 완전히 다른 해시값을 생성함
    - 단방향 암호화는 비밀번호와 같은 문자열을 암호화하는데 사용되지만 실제 암호화는 바이트 데이터를 기준으로 동작
        + 따라서 단방향 암호화를 진행할 때, 바이트 배열로 변환해서 암호화 진행
        + 암호화가 끝난 바이트 배열은 Base64 등으로 문자열로 변환해서 저장
    - 값의 비교
        + 단방향 암호화는 해시 함수로 생성한 값이 같으면 두 데이터가 같다고 간주
    - 단방향 암호화는 원본 데이터로 복호화할 수 없다
        + 정보손실때문에 복호화가 불가능
            - 긴 데이터를 짧은 해시로 압축하면서 `정보가 손실`
            - 손실된 정보로는 원본을 복원할 수 없음
            ```
            "hello" -> 64자리 해시
            "hello world from a very long sentence" -> 64자리 해시
            ```
    - 해시 salt
        + 같은 문자열 데이터라도 다른 해시값이 나오도록 만들어주는 랜덤 데이터
            ```java
            // Salt 없이 해시
            hash("password123") → "ef92b778ba..."
            hash("password123") → "ef92b778ba..."  // 항상 같음!

            // 사용자마다 다른 랜덤 Salt 생성
            User A:
            salt: "a8f5k2p9"
            hash("password123" + "a8f5k2p9") → "x7j9m3n2..."

            User B:
            salt: "q3w7e1r5"  // 다른 Salt!
            hash("password123" + "q3w7e1r5") → "p2l8k6h4..."  // 다른 해시!
            ```

+ 양방향 암호화
    - 암호화와 복호화가 모두 가능한 방식
        + SSH, HTTPS 등에서 주로 사용되고 대표적인 양방향 알고리즘에는 AES, RSA가 있다
        + 암호화와 복호화에 키를 사용
        + 대칭키
            - 암호화와 복호화에 같은 키 사용
            - 키가 유출되면 누구나 암호화된 데이터를 복호화할 수 있으므로 보안이 특히 더 중요
        + 비대칭키
            - 암호화와 복호화에 다른 키 사용 (개인 키와 공개 키)
            - 공개 키로 암호화, 개인 키로 복호화
                + 기밀성의 보장
                    ```
                    발신자(Alice)                    수신자(Bob)
                    │                               │
                    │  Bob의 공개키로 암호화          │
                    │  "Hello" → 암호문              │
                    ├──────────────────────────────>│
                    │                               │
                    │                          Bob의 개인키로 복호화
                    │                          암호문 → "Hello"
                    ```
                    - Bob의 공개키는 누구나 접근 가능
                    - 하지만 Bob의 개인키로만 복호화 가능
                    - 오직 Bob만 내용확인 가능
            - 개인 키로 암호화, 공개 키로 복호화 (전자서명)
                + 인증과 무결성 보장
                    ```
                    발신자(Alice)                    수신자(Bob)
                        │                               │
                        │  Alice의 개인키로 서명          │
                        │  "Hello" + 서명                │
                        ├──────────────────────────────>│
                        │                               │
                        │                          Alice의 공개키로 검증
                        │                          ✓ 진짜 Alice가 보냄
                        │                          ✓ 내용이 변조되지 않음
                    ```
                    - Alice의 개인키로만 서명 가능
                    - 누구나 Alice의 공개키로 검증 가능
                    - Alice가 보냈다는 사실 증명

### HMAC을 이용한 데이터 검증
HMAC이란?  
HMAC (Hash-based Message Authentication Code)는 해시 기반 메시지 인증 코드이며 해시 함수에 비밀 키를 조합한 것이다  
주로 메시지의 무결성과 인증을 동시에 보장하는데 사용한다

```java
// 단순 해시만 사용
String message = "송금: 1,000원";
String hash = SHA256(message);
// hash: "a7f3e9..."

// 문제: 누구나 같은 해시를 만들 수 있음!
String fakeMessage = "송금: 1,000,000원";
String fakeHash = SHA256(fakeMessage);
// 공격자가 메시지와 해시를 모두 변조 가능
```

+ 해시는 공개 알고리즘이라 누구나 계산 가능
+ 매시지를 변조하고 새로운 해시를 계산하면 끝
+ 발신자를 확인할 방법이 없다

HMAC을 사용하면 어떻게 다른가?  

```java
// HMAC 사용
String message = "송금: 1,000원";
String secretKey = "only_alice_and_bob_know";
String hmac = HMAC_SHA256(message, secretKey);
// hmac: "x9k2m5..."

// 공격자가 메시지 변조 시도
String fakeMessage = "송금: 1,000,000원";
String fakeHmac = HMAC_SHA256(fakeMessage, secretKey);
// ❌ 문제: 공격자는 secretKey를 모름!
// 올바른 HMAC을 만들 수 없음
```

+ 비밀 키를 알아야 올바른 HMAC 생성 가능
+ 메시지가 변조되면 HMAC 검증 실패
+ 비밀 키를 아는 사람이 보냈다 증명 가능
