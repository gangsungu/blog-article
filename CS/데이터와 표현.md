## 데이터와 표현

### 비트와 바이트
+ 컴퓨터는 10진법이 아닌 2진법을 사용해 정보를 저장한다
    - 0과 1만을 사용
    - 전기신호의 전압이 일정 기준보다 높으면 1, 그렇지 않으면 0으로 변환

+ 비트 (bit)
    - 0과 1을 표현할 수 있는 최소 단위
    - 여러 개의 비트를 조합하여 데이터를 표현
        + 3개의 비트가 있으면 2 * 2 * 2 = 8, 총 8개의 표현이 가능 (2<sup>n</sup>개의 표현이 가능)
+ 바이트 (byte)
    - 8비트를 한 묶음으로 표현한 단위
        + 1바이트당 256(2<sup>8</sup>)가지의 데이터 표현이 가능

### 컴퓨터의 숫자 표현 (정수)
+ 음수의 표현
    - 부호 비트
        + 컴퓨터는 n비트에서 가장 왼쪽의 비트(최상위 비트)를 부호 비트로 사용하여 음수를 표현
        + 부호 비트가 1이면 음수, 0이면 양수
    - 2의 보수
        + 음수를 저장하기 위해 사용하는 방법
        + 모든 비트를 반전시키고 1을 더한다
        + n개의 비트로 표현할 수 있는 정수의 범위는 -2<sup>(n-1)</sup> ~ 2<sup>(n-1)</sup>-1
            - 즉 n=4일 때, 표현가능한 정수의 범위는 -8 ~ 7

    |4비트 표현조합|10진수|4비트 표현조합|10진수|
    |---|---|---|---|
    |0000|0|1000|-8|
    |0001|1|1001|-7|
    |0010|2|1010|-6|
    |0011|3|1011|-5|
    |0100|4|1100|-4|
    |0101|5|1101|-3|
    |0110|6|1110|-2|
    |0111|7|1111|-1|

    - singed와 unsigned
        + `1010` 비트 패턴이라도 어떻게 해석하느냐에 따라 다른 값이 된다
        + signed (부호있는 정수)
            - 2의 보수 사용
            ```
            1010
            ↑
            이 비트가 1이면 음수!

            1010 = -6 (2의 보수 방식)
            ```
        + unsigned (부호없는 정수)
            - 2의 보수 사용하지 않음
            ```
            1010 = 1×8 + 0×4 + 1×2 + 0×1 = 10
            ```

            |언어|기본값|unsigned 지원|signed 명시|
            |---|---|---|---|
            |Java|signed|❌ 없음|불필요 (항상 signed)|
            |C<sup>++</sup>|signed|✅ 있음|선택가능|

### 컴퓨터의 숫자 표현 (실수)
+ 부동소수점 (Floating Point)
    - 컴퓨터가 실수(소수)를 표현하는 방법
    - 소수점의 위치가 고정되지 않고 움직인다는 의미
    - 정수만으로 표현하지 못하는 값을 표현하기 위해 사용

    ```
    3.14 (원주율)
    0.5 (반)
    -273.15 (절대영도)
    0.0000001 (아주 작은 수)
    1000000000000.0 (아주 큰 수)
    ```

    - IEEE754 표준 (부동소수점 표준)
        + 현대 컴퓨터에서 부동소수점을 표현하기 위해 사용하는 국제 표준
        + 구조
            - 부호 (Sign) 1비트 | 지수(Exponent) 8비트 | 가수(Mantissa) 23비트
            - 부호 비트 : 숫자의 양수, 음수 (방향)을 결정
            - 지수 비트 : 숫자의 스케일 (범위)를 결정
        + 공식
            - (-1)^부호 × 가수 × 2^지수
        + 소수 부분 이진 변환 규칙
            - 소수에 2를 곱하기
            - 결과의 정수를 기록 (0 또는 1)
            - 결과의 소수만 남기고 소수 부분이 0이 될때까지 반복
                + 예시1 : 0.5
                    ```
                    0.5 × 2 = 1.0
                            ↑ ↑
                        정수:1 소수:0

                    소수 부분이 0 → 종료!
                    0.5₁₀ = 0.1₂ ✅
                    ```
                + 예시2 : 0.25
                    ```
                    0.25 × 2 = 0.5  → 정수: 0, 소수: 0.5
                    0.5  × 2 = 1.0  → 정수: 1, 소수: 0.0

                    소수 부분이 0 → 종료!

                    0.25₁₀ = 0.01₂ ✅
                    ```
            - 왜 이 방법이 맞을까? 수학적으로 검증해보면
                ```
                0.1₂ = 1 × 2⁻¹ = 1 × 1/2 = 0.5₁₀ ✅
                0.01₂ = 1 × 2⁻² = 1 × 1/4 = 0.25₁₀ ✅
                0.11₂ = 1 × 2⁻¹ + 1 × 2⁻² = 0.5 + 0.25 = 0.75₁₀ ✅
                ```
    - 부동소수점의 한계
        + 정확도 문제
            ```java
            double a = 0.1;
            double b = 0.2;
            double c = a + b;

            System.out.println(c);  // 0.30000000000000004 ← 어?!
            System.out.println(c == 0.3);  // false!
            ```
            - 0.1을 이진수로 정확히 표현할 수 없다!
                + 무한소수의 문제
                    ```
                    0.1 × 2 = 0.2  → 정수: 0, 소수: 0.2
                    0.2 × 2 = 0.4  → 정수: 0, 소수: 0.4
                    0.4 × 2 = 0.8  → 정수: 0, 소수: 0.8
                    0.8 × 2 = 1.6  → 정수: 1, 소수: 0.6
                    0.6 × 2 = 1.2  → 정수: 1, 소수: 0.2 ← 반복 시작!
                    0.2 × 2 = 0.4  → 정수: 0, 소수: 0.4
                    ...

                    0.1₁₀ = 0.0001100110011...₂ (무한 반복!)

                    // 따라서 0.1 + 0.2가 0.3이 아니다
                    ```
            - 2의 거듭제곱 분수만 정확히 표현 가능하다
    - 부동소수점에서 음수 표현하기
        + 부동소수점에서 지수는 양수와 음수 모두 필요하다
            ```
            큰 수: 1.5 × 2⁸    → 지수: +8
            작은 수: 1.5 × 2⁻⁸  → 지수: -8
            ```
            - 하지만 지수를 저장할 8비트는 unsigned 방식, 그렇다면 음수를 어떻게 표현할까?
        + 127을 더해서 음수를 양수로 저장
            - 32비트 float의 경우
                ```
                실제 지수 범위: -126 ~ +127
                저장된 지수 범위: 1 ~ 254

                공식: 저장된 지수 = 실제 지수 + 127

                예시:
                실제 지수 +3  → 저장: 3 + 127 = 130
                실제 지수  0  → 저장: 0 + 127 = 127
                실제 지수 -3  → 저장: -3 + 127 = 124
                ```
        + 그렇다면 왜 127일까?
            - 8비트가 표현할 수 있는 범위는 0 ~ 255
            - 0은 0을 의미, 255는 특수값 따라서 실제 사용가능한 숫자는 1 ~ 254로 총 254개
            - 중간값: (1 + 254) / 2 ≈ 127.5 → 127

        ```
        비트: 0 10000010 10010000000000000000000

        1. 부호: 0 → 양수
        2. 지수: 10000010₂ = 130₁₀
        실제 지수: 130 - 127 = 3
        3. 가수: 10010000000000000000000
        실제 가수: 1.1001 (앞에 1 추가)

        값 = (+1) × 1.1001₂ × 2³
        = 1.1001₂ × 2³
        = 11001₂ (소수점 오른쪽으로 3칸)
        = 1100.1₂
        = 12.5₁₀ ✅
        ```

        + 왜 지수 비트에서 signed 방식을 사용하지 않을까?
            - 2의 보수를 사용한다면?
                ```
                8비트 signed: -128 ~ 127

                문제점:
                - 지수 비교가 복잡해짐
                - 큰 수인지 작은 수인지 판단 어려움

                예:
                11111111 (2의 보수 -1)
                01111111 (2의 보수 +127)

                비트 패턴으로 봤을 때:
                11111111 > 01111111 (unsigned 비교)
                하지만 실제 값은: -1 < 127
                ```
            - bias 방식을 사용한다면
                ```
                실제 지수 -3 → 저장: 124 (01111100)
                실제 지수 +3 → 저장: 130 (10000010)

                비트 패턴: 01111100 < 10000010
                실제 값:   -3 < 3 ✅

                부호 없는 정수로 비교해도 순서가 맞음!
                ```