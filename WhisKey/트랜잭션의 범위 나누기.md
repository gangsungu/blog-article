## 트랜잭션의 범위 나누기

아래와 같은 코드가 있다. 해당 코드에서 문제점은 무엇일까?

```java
@Transactional
public void register(ReviewCommand reviewDto) {
    Member member = memberRepository.findById(reviewDto.memberId())
        .orElseThrow(() -> ErrorCode.NOT_FOUND.exception("존재하지 않는 회원입니다."));

    Whiskey whiskey = whiskeyRepository.findById(reviewDto.whiskeyId())
        .orElseThrow(() -> ErrorCode.NOT_FOUND.exception("존재하지 않는 위스키입니다."));

    boolean check = reviewRepository.existsByWhiskeyIdAndMemberId(whiskey.getId(), reviewDto.memberId());
    if (check) {
        throw ErrorCode.CONFLICT.exception("이미 리뷰를 등록하셨습니다.");
    }

    Review review = Review.builder()
        .whiskey(whiskey)
        .member(member)
        .starRate(reviewDto.starRate())
        .content(reviewDto.content())
        .build();

    reviewRepository.save(review);
    ratingService.addReview(whiskey.getId(), reviewDto.starRate());
}
```

크게는 두가지를 발견할 수 있다.  
우선 중복 리뷰 체크 로직이 서비스에 들어가있는 점이 있는데, 이건 다른 브랜치에서 수정할 것이고...

다른 하나는!

트랜잭션의 범위가 너무 넓다는 점이 있다.  
트랜잭션의 범위가 넓으면 무슨 문제가 있느냐.  
커넥션을 오래 잡게되면 락이 발생할 가능성이 커진다.

```
1. 리뷰 등록 (DB 락 -> 트랜잭션 A)
2. 평점 업데이트 호출 (트랜잭션 A)
3. 평점 계산 로직 (추가 DB 조회/업데이트)
4. 트랜잭션 커밋
```
> 이렇게 4단계를 거치는 동안 커넥션과 락을 공유해야 한다  
당연히 문제가 발생할 가능성이 커진다

그리고 하나 말하지 않은 중요한 사실이 있는데, ratingService의 addReview 메소드를 보면 레디스에서 평점을 계산하도록 코드를 짜놓았다.

```java
@Transactional  // MySQL 트랜잭션 시작
public void register() {
    reviewRepository.save(review);        // MySQL 작업
    ratingService.addReview(...);         // Redis 작업 ← 이상함!
}  // MySQL 트랜잭션 끝
```
> 정리하면 이런 순서로 작업이 이루어진다.

당연하지만 MySQL 트랜잭션 안에 Redis 트랜잭션을 넣는건 의미가 없다.  
아래 4가지로 정리할 수 있다.

1. MySQL 트랜잭션이 Redis를 제어할 수 없음  -> 서로 다른 저장소
2. Redis 작업 오나료까지 MySQL 커넥션/락을 점유 -> 불필요한 지연
3. Redis 작업이 실패해도 MysQL은 롤백되지 않음  -> 원자성 보장 불가
4. 싱글 스레드로 동작하는 Redis는 이미 원자성이 보장되므로 트랜잭션으로 묶는건 의미가 없다

그럼 MySQL 트랜잭션과 Redis를 어떻게 이어야할까?  
이런 경우에 ***이벤트 기반 처리***가 등장한다.

### 이벤트 기반 처리
이벤트 기반 처리란?
간단히 말해서 리뷰 등록이 완료되면 리뷰가 등록되었다는 이벤트를 만들고 다른 곳에서 이 이벤트를 받아 평점 업데이트를 진행하는 처리 방식이다.  
현재 코드는 동기 처리방식으로 `하나의 트랜잭션에서 순서대로 코드가 진행`된다.

```
리뷰 등록 → 평점 업데이트 → 완료
(하나의 트랜잭션에서 순차적으로 처리)
```

이것을 이벤트 기반 처리방식으로 수정하면 `비동기로 코드가 진행`된다.

```
리뷰 등록 → 완료 → "리뷰 등록됨" 이벤트 발행
                 ↓
           다른 곳에서 이벤트 수신 → 평점 업데이트
```

위의 상황을 다시 코드로 정리하면 아래와 같다

```java
@Transactional  // MySQL 트랜잭션
public void register() {
    // MySQL 작업
    reviewRepository.save(review);
    
    // Redis 작업 (MySQL 트랜잭션과 무관한데 억지로 묶임)
    ratingService.addReview(...);
}
```

이것을 이벤트 기반 처리로 수정하면 아래처럼 수정할 수 있다.

```java
@Transactional  // MySQL만 처리
public void register() {
    reviewRepository.save(review);
    
    // MySQL 트랜잭션 커밋 후 이벤트 발행
    eventPublisher.publishEvent(new ReviewRegisteredEvent(...));
}

@EventListener  // 별도 처리
public void handleReviewRegistered(ReviewRegisteredEvent event) {
    // Redis 원자적 연산
    ratingService.addReview(event.getWhiskeyId(), event.getStarRate());
}
```

위의 예제에서는 @EventListener 어노테이션을 사용했지만 @TransactionalEventListener라는 어노테이션도 있다.  
이제 두 어노테이션의 차이를 알아보자

#### @EventListener
```java
@EventListener
public void handleReviewRegistered(ReviewRegisteredEvent event) {
    // 이벤트 발행되면 바로 실행
    ratingService.addReview(...);
}
```
+ 즉시 실행 : 이벤트가 발행되면 바로 처리
+ 같은 트랜잭션 : 이벤트를 발행한 트랜잭션과 같은 트랜잭션에서 실행

#### @TransactionalEventListener
```java
@TransactionalEventListener(phase = TransactionPhase.AFTER_COMMIT)
public void handleReviewRegistered(ReviewRegisteredEvent event) {
    // 트랜잭션 커밋 후에 실행
    ratingService.addReview(...);
}
```
+ 트랜잭션 상태에 따라 실행 : 커밋 후, 롤백 후 등 이벤트를 선택할 수 있음
+ 별도 실행 : 원본 트랜잭션과 독립적으로 실행

### 결론
우리 코드에서는 별도의 트랜잭션을 사용해야 하므로 @TransactionalEventListener 어노테이션을 사용하는 것이 맞다  
