WhisKey라는 이름의 사이드 프로젝트를 개발 중이다.  
이름은 Whisky + Key로 `위스키를 찾는 키가 되자`라는 뜻을 내포하고 있다.

현재 회사에서 기술적인 욕구를 전혀 충족시켜주지 못하고 있으므로  
그동안 사용하고 싶었던 기술들을 모두 사용해보려고 노력하고 있다.

### 레이어드 아키텍처 기반의 멀티모듈

사이드 프로젝트 개발 전, 아키텍처 구조를 멀티 모듈로 잡았다.  
멀티모듈을 선택한 이유는 생각보다 하찮은데, 이클립스는 프로젝트 구조를 워크스페이스로 잡는다.  
따라서, 프로젝트가 커질수록 디렉토리 관리가 복잡해지고 코드 추적이 어려워진다.  
하지만 인텔리제이는 하나의 프로젝트에 여러개의 멀티모듈을 설정할 수 있다.  
그래서 `멀티모듈을 선택하여 코드를 분리해보자`라는 생각으로 멀티 모듈로 프로젝트를 나누어 생성했다.

```java
whiskey-service/
├── module-api
├── module-domain
├── module-common
```

> 나중에 관심사별로 모듈을 나눈 형태를 `레이어드 아키텍처`라고 부른다는 것을 알았다..😆

- module-api  
    이름 그대로 api를 실행하기 위한 코드들이 존재한다.  
    AuthController, AuthService, AuthRepository 등  

- module-domain  
    Whiskey나 Member같은 엔티티 객체들이 존재한다.  

- module-common  
    api에서 공통으로 사용하는 Response 객체나 ErrorCode 등이 존재한다.

각 모듈들의 의존성 방향은 아래와 같다

```java
module-api → module-domain → module-common
```

아마 읽다가 이상한 부분을 눈치챘을지도 모르겠는데, 기존 프로젝트 구조는 아래의 3가지 관점을 위배하고 있다.

1. 단일 책임 원칙(SRP)  
    각 모듈은 각자의 책임이 있다.
    - module-api  
    어떻게 외부와 소통할 것인가
    - module-domain  
    비즈니스 로직을 어떻게 처리할 것인가

그런데, 기존의 프로젝트 구조를 보면 module-api에 Service와 Repository가 존재한다.  
따라서 객체지향 5원칙 중 단일 책임 원칙을 위배하고 있다.

2.  의존관계 역전 원칙(DIP)  
    기존엔 module-api에서 module-domain의 엔티티에 직접 접근하고 있었다.

``` java
// ❌ module-api
public record MemberResponse(...) {
    public static MemberResponse from(Member member) {  // 엔티티 직접 의존
        // ...
    }
}
```

그래서 아래와 같은 의존성 방향이 그려졌다.

```java
// ❌ 
module-api → module-domain → module-api (순환!)
```

3.  개방-폐쇄 원칙(OCP)  
    단일 책임 원칙과 의존관계 역전 원칙을 어김으로서 간접적으로 개방-폐쇄 원칙도 어긴 개발을 하고 있었다.  
    예를 들어, API 스펙이 변경되면? Service도 같이 변경해야했다.
    
5.  테스트 용이성  
    기존 코드는 책임이 섞여있는 구조라 테스트가 어려운 상태였다.그래서 난 login()만 테스트하고 싶은데, 실제 DB도 연결해야해, JWT 토큰도 발급해야해, HTTP 응답 객체도 고려해야해  
    확인해야할 부분이 너무 많았다!😱

```
// module-api에 모든 게 다 있던 상황  
module-api:  
├── AuthController  
├── AuthService // 🚨 비즈니스 로직  
├── AuthRepository // 🚨 데이터 접근  
└── JwtResponse  

// 테스트할 때 문제:  
// - Controller 테스트 시 DB, JWT 토큰 생성 등 모든 걸 고려해야 함 
// - Service만 단위 테스트하기 어려움
```

또, 사소하지만 엔티티 객체가 직접 노출되므로 지연 로딩과 관련된 문제가 발생할 가능성도 존재했다.

### 결론

개발 초기 단계라 프로젝트 구조를 금방 리팩토링 할 수 있었다.  
리팩토링한 프로젝트 구조는 아래와 같다.

```
module-api: 
- Controller
- Request/Response DTO
- API 관련 설정

module-domain:
- Entity
- Repository Interface
- Domain Service
- Repository 구현체 (JPA)

module-common:
- 공통 Exception
- 공통 Util
- 공통 Config
```

개발자는 단순히 코드를 작성하는 것뿐만이 아닌 적절한 아키텍처 구조를 고민하고  
더 나아가 클린 코드를 지향해야 한다는 것을 배웠다👍