## 트랜잭션이란?

트랜잭션은 데이터베이스에서 하나의 **논리적 작업 단위**를 말한다.  
즉, 여러 개의 작업들을 하나로 묶어 `전부 성공하거나, 전부 실패하거나`를 보장한다.

### 일상 예시로 이해하기

은행 계좌이체를 생각해보자

```
1. 내 계좌에서 10만원 출금
2. 친구 계좌에 10만원 입금
```

1번은 성공했는데, 2번이 실패하면?  
내 돈만 사라지고 친구는 돈을 못 받는 상황이 벌어진다!😢

그래서 두 작업을 `하나의 트랜잭션`으로 묶어 둘 다 성공하거나 둘 다 실패하도록 만든다  
그야말로 **All or Nothing**

### 왜 트랜잭션이 필요할까?

-   데이터 정합성 보장

```sql
-- 주문 처리 예시
BEGIN TRANSACTION;
    INSERT INTO orders (user_id, product_id, quantity) VALUES (1, 100, 2);
    UPDATE products SET stock = stock - 2 WHERE id = 100;
    UPDATE users SET points = points - 200 WHERE id = 1;
COMMIT;
```

> 주문 추가, 재고 차감, 포인트 차감이 모두 성공해야 올바른 주문이다.

-   동시성 제어

여러 사용자가 동시에 같은 데이터를 수정할 때, 발생하는 문제를 방지한다.

-   장애복구

트랜잭션을 커밋하기 전엔 DB에 반영되지 않으므로 시스템이 중간에 다운되어도 데이터 일관성을 유지할 수 있다.

장애복구 시나리오는 크게 두가지가 있다.

1.  트랜잭션 중간에 시스템 다운

```sql
BEGIN TRANSACTION;
    INSERT INTO orders VALUES (1, 'A', 100);  -- 실행됨
    UPDATE products SET stock = stock - 1;     -- 실행됨
    -- 여기서 시스템 다운! 💥
    UPDATE users SET points = points - 100;    -- 실행 안됨
COMMIT;  -- 실행 안됨
```

> 결과 : 시스템 재시작 후, `모든 변경사항이 롤백`되어 처음 주문 전 상태로 돌아감

2.  커밋 완료 후 시스템 다운

```sql
BEGIN TRANSACTION;
    INSERT INTO orders VALUES (1, 'A', 100);
    UPDATE products SET stock = stock - 1;
    UPDATE users SET points = points - 100;
COMMIT;  -- ✅ 성공적으로 커밋됨
-- 여기서 시스템 다운! 💥
```

> 결과 : 시스템 재시작 후, `주문이 보존`됨

그렇다면 데이터베이스가 이를 어떻게 보장할 수 있을까?

WAL(Write-Ahead-Logging)이라는 것이 있다.

```
- 실제 데이터 수정 전에 로그부터 디스크에 기록
- 로그에 `트랜잭션 시작`, `데이터 변경`, `커밋` 순서로 기록
- 장애 발생시 로그를 불러와 복구!😲
```

복구과정은 아래와 같다

시스템을 재시작하면

```
- 로그를 스캔하여 커밋되지 않은 트랜잭션을 확인
- 커밋되지 않은 트랜잭션을 찾으면 롤백(UNDO)
- 커밋된 트랜잭션을 찾으면 재실행(REDO)
```

### 트랜잭션의 상태

트랜잭션은 다음과 같은 상태를 가진다

```
Active (활성) → Partially Committed (부분 완료) → Committed (완료)
    ↓                                              ↑
Failed (실패) → Aborted (중단) ──────────────────┘
```

순서대로

```
- Active : 트랜잭션이 실행 중인 상태👍  
- Partially Committed : 마지막 연산까지 실행했지만 아직 디스크에 반영되지 않은 상태👍  
- Committed : 모든 작업이 성공적으로 완료된 상태👍  
- Failed : 실패💥  
- Aborted : 실패한 트랜잭션을 롤백한 상태  
```

### 트랜잭션의 연산

1.  BEGIN / START TRANSACTION

트랜잭션 시작을 선언한다.

2.  Commit

모든 작업을 확정, 커밋하면 롤백이 불가능해진다.

3.  Rollback

트랜잭션을 취소하고 트랜잭션 시작 전 상태로 되돌린다.

4.  Savepoint

트랜잭션 중간에 세이브포인트를 만든다.

```sql
BEGIN TRANSACTION;
    INSERT INTO orders VALUES (1, 'A', 100);
    SAVEPOINT sp1;
    UPDATE products SET stock = stock - 1;
    -- 오류 발생 시
    ROLLBACK TO sp1;  -- sp1 지점으로만 롤백
COMMIT;
```

### 트랜잭션 사용 중 주의할 점

1.  트랜잭션은 가능한 짧게 잡자

```java
// 나쁜 예 - 트랜잭션이 너무 길어요
@Transactional
public void processOrder() {
    // DB 작업
    saveOrder();
    // 외부 API 호출 (시간 오래 걸림)
    callPaymentAPI();  // 이건 트랜잭션 밖에서!
    // DB 작업
    updateInventory();
}
```

2.  중첩 트랜잭션 주의!

`Propagation` 키워드를 좀 더 알아보자

3.  데드락 주의

여러 트랜잭션이 서로의 락을 기다리며 무한 대기하는 상황❗️

### 이해도 확인 문제

문제 1 : 다음 상황에서 어떤 부분을 트랜잭션으로 묶어야 할지 설계해보자.

온라인 쇼핑몰 주문 처리:

1.  사용자 로그인 확인
2.  상품 재고 확인
3.  주문 테이블에 데이터 삽입
4.  재고 차감
5.  결제 API 호출
6.  배송 정보 등록
7.  주문 완료 이메일 발송

펼치기

```
2, 3, 4번을 묶는다!  
5번도 같이 묶는게 맞지않을까 생각하겠지만, 아래의 3가지 이유때문에 따로 빼는게 맞다!  
1. 외부 결제 API 호출은 요청하고 응답받기까지의 시간이 오래 걸려서 전체 트랜잭션이 길어진다.  
2. 네트워크 타임아웃으로 결제가 실패할 가능성도 있다.
3. 이런 경우 결제 API를 재호출하면 끝

간단하게 코드로 보자면 아래와 같다

// 1. 먼저 주문/재고 트랜잭션 처리
@Transactional
public Order createOrder(OrderRequest request) {
    // 재고 확인, 주문 생성, 재고 차감
}

// 2. 결제는 별도로 처리 (실패 시 보상 트랜잭션)
public void processPayment(Order order) {
    try {
        paymentAPI.charge(order);
        order.setStatus("PAID");
    } catch (Exception e) {
        // 주문 취소하고 재고 복구
        cancelOrder(order);  
    }
}
```

문제 2 : 아래 코드의 문제점을 찾아보자

```
@Service
public class OrderService {
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        updateInventory(order.getProductId(), order.getQuantity());
    }

    @Transactional
    public void updateInventory(Long productId, int quantity) {
        // 재고 업데이트 로직
    }
}
```

펼치기

```
위에서 키워드로 언급한 트랜잭션 전파(Propagation) 문제다.

@Service 
public class OrderService {
    @Transactional
    public void createOrder(Order order) {
        orderRepository.save(order);
        updateInventory(...); // <- 이건 그냥 일반 메서드 호출!
    }

    @Transactional  // <- 이 어노테이션이 무시됨!
    public void updateInventory(Long productId, int quantity) {
        // 같은 트랜잭션에서 실행됨
    }
}

왜 트랜잭션이 무시될까? Spring AOP는 `프록시 패턴`을 사용하는데, 같은 객체 내부에서 메서드를 호출하면 프록시를 거치지 않아 `@Transactional`이 적용되지 않는다.

그렇다면 해결방법은 무엇이 있을까?
1. 별도의 서비스로 분리(가장 쉽다!)👏
2. @Transactional(propagation = Propagation.REQUIRES_NEW) 사용
```

문제 3 : 트랜잭션없이 다음 상황이 발생하면 어떤 일이 벌어질까?

1.  A가 계좌에서 10만원 출금 (성공)
2.  시스템 장애 발생
3.  B의 계좌에 10만원 입금 (실행 안됨)

펼치기

```
다시 한번 트랜잭션 도입의 필요성을 느끼게 해주는 **데이터 불일치** 사례다.

1. 전체 시스템 관점에서 10만원이 증발🔥
2. A 입장에서는 돈을 보냈는데, B 입장에서는 못받은 상황🔥
3. 복구하려면 수동으로 데이터 정정 작업을 해야한다..😨

이런 불상사를 방지하려면 트랜잭션 내부에서 일련의 과정을 처리하면 된다.

BEGIN TRANSACTION;
    UPDATE account SET balance = balance - 100000 WHERE id = 'A';
    UPDATE account SET balance = balance + 100000 WHERE id = 'B';
COMMIT;  -- 둘 다 성공해야만 확정
```

문제 4 : 두명의 사용자가 동시에 같은 계좌에서 이체를 실행하면 어떤 일이 벌어질까?

펼치기

```
이 문제는 트랜잭션의 격리수준에 대해 묻는 문제다.

아래와 같은 시간순서로 이체가 실행된다면

시간 T1: 사용자1 트랜잭션 시작
시간 T2: 사용자1이 A계좌 조회 (잔액: 100만원)
시간 T3: 사용자2 트랜잭션 시작  
시간 T4: 사용자2가 A계좌 조회 (잔액: 100만원) <- 아직 사용자1이 커밋 안함
시간 T5: 사용자1이 A계좌에서 10만원 차감 (90만원으로 수정)
시간 T6: 사용자2가 A계좌에서 20만원 차감 (80만원으로 수정) <- 문제!
시간 T7: 사용자1 커밋
시간 T8: 사용자2 커밋

A 계좌는 80만원이 되어야하는데, 실제로는 사용자1의 요청이 무시된다.

왜 이런 일이 벌어질까?

데이터베이스는 `트랜잭션 격리 수준`에 따라 다르게 동작한다.

1. Read Uncommited (가장 낮은 격리수준)  
- 다른 트랜잭션의 커밋하지 않은 데이터도 읽을 수 있음
- Dirty Read 발생 가능

2. Read Committed (MySQL 기본 값)
- 커밋된 데이터만 읽을 수 있음
- 하지만 예제와 같은 Lost Update 발생 가능성 존재

3. Repeatabled Read
- 같은 트랜잭션 내에서는 항상 같은 값을 읽음
- Phantom Read 가능성 존재

4. Serializable (가장 높은 격리수준)
- 트랜잭션이 완전히 순차적으로 동작

해결방법은 아래와 같은 방법들이 있다.

1. 비관적 락(Pessimistic Lock)
@Query("SELECT a FROM Account a WHERE a.id = :id FOR UPDATE")
Account findByIdForUpdate(String id);

2. 낙관적 락(OPtimistic Lock)
@Entity
public class Account {
    @Version
    private Long version;
    // ...
}

3. 원자적 연산 사용
UPDATE account SET balance = balance - 100000 WHERE id = 'A';
UPDATE account SET balance = balance + 100000 WHERE id = 'B';
```
