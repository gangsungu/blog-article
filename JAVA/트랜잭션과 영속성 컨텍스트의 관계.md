## 트랜잭션과 영속성 컨텍스트의 관계
메서드에 객체를 전달할 때, 엔티티를 그대로 보내는 방법과 Request 객체를 생성하고 엔티티를 여기에 담아 전달하는 방법이 있다  
그런데 엔티티를 직접 넘기는 방법은 문제가 있다!  

개발 중인 프로젝트 코드를 예로 들면

```java
@Transactional
public void completePayment(Payment payment, Order order, ...) {
    // payment, order는 영속 상태
    payment.completePayment(...);  // 변경 감지 동작
    
    // 예외 발생 시
    paymentCompensationService.cancelPayment(payment, order, ...);
}

@Transactional(propagation = REQUIRES_NEW)
public void cancelPayment(Payment payment, Order order, ...) {
    // 여기서 payment, order는 어떤 상태일까?
    payment.cancelPayment();  // 이게 제대로 동작할까?
}
```
REQUIRES_NEW로 새 트랜잭션을 열면  
+ 새로운 영속성 컨텍스트가 생성됨
+ 그런데 넘어온 payment, order 엔티티는 다른 영속성 컨텍스트의 엔티티
+ 그래서 cancelPayment 메서드 안의 payment와 order는 준영속 상태가 되어버린다
> 즉, 변경감지가 안될 수 있음  

```java
public void cancelPayment(Payment payment, Order order, ...) {
    // 누군가 실수로
    payment.someMethod();  // payment 상태 변경
    order.someMethod();    // order 상태 변경
    
    // 이게 원래 트랜잭션에 영향을 줄까, 안 줄까?
    // 예측하기 어려움
}
```
또, 엔티티를 넘기면 어디서든 상태를 바꿀 수 있어 의도하지 않은 사이드 이펙트가 발생할 수 있다

### 결론
스프링에서 기본 전략은 **트랜잭션 당 하나의 영속성 컨텍스트**  

```java
Payment payment = new Payment(...);  // 메모리 주소 0x1234

// 트랜잭션 A
영속성 컨텍스트 A: { 0x1234 → 관리중 }
payment.setStatus("DONE");  // 변경 감지 O

// 트랜잭션 B (REQUIRES_NEW)
영속성 컨텍스트 B: { 비어있음 }  // 0x1234를 모름
payment.setStatus("CANCEL");  // 변경 감지 X (준영속이라)
```
즉, 전달용 객체를 만들고 엔티티에서 필요한 컬럼만 담아 넘겨주는 것이 옮다