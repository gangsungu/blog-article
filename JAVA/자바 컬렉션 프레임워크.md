## 자바 컬렉션 프레임워크에 대해 알아보자

컬렉션은 `여러 개의 데이터를 하나로 묶어서 관리하는 자료구조`  
배열과 비슷한 개념이지만 크기가 동적으로 변할 수 있고 다양한 기능을 제공한다  
컬렉션 프레임워크는 크게 3가지 인터페이스로 나뉜다

### 컬렉션 프레임워크 구조
1. List 인터페이스
    + `순서가 있고 중복을 허용`
    + 인덱스로 접근 가능
    + 주요 구현체 : ArrayList, LinkedList, Vector

    ```java
    List<String> arrayList = new ArrayList<>();
    arrayList.add("사과");
    arrayList.add("바나나");
    arrayList.add("사과"); // 중복 허용
    System.out.println(arrayList.get(0)); // "사과"
    ```

2. Set 인터페이스
    + `순서가 없고 중복을 허용하지 않음`
    + 집합의 개념
    + 주요 구현체 : HashSet, LinkedHashSet, TreeSet

    ```java
    Set<String> hashSet = new HashSet<>();
    hashSet.add("사과");
    hashSet.add("바나나");
    hashSet.add("사과"); // 중복이므로 추가되지 않음
    System.out.println(hashSet.size()); // 2
    ```

3. Queue 인터페이스
    + FIFO(First In First Out) 구조
    + 먼저 들어간 것이 먼저 나옴
    + 주요 구현체 : LinkedList, PriorityQueue, ArrayDeque

    ```java
    Queue<String> queue = new LinkedList<>();
    queue.offer("첫번째");
    queue.offer("두번째");
    System.out.println(queue.poll()); // "첫번째"
    ```

4. Map 인터페이스
    + 컬렉션과 별도
    + key-value 쌍으로 데이터를 저장하는 구조
    + key는 중복 불가, value는 중복 가능
    + 주요 구현체 : HashMap, LinkedHashMap, TreeMap, Hashtable

    ```java
    Map<String, Integer> map = new HashMap<>();
    map.put("사과", 1000);
    map.put("바나나", 2000);
    System.out.println(map.get("사과")); // 1000
    ```

### List 인터페이스
* ArrayList
    + 내부구조 : 동적 배열
        - 내부적으로 Object[] 배열을 사용
        - 기본 크기는 10, 용량 부족시 1.5배씩 확장

        ```java
        // 내부 동작 예시
        ArrayList<String> list = new ArrayList<>(); // 초기 용량 10
        // 11번째 요소 추가시 용량이 15로 확장됨
        ``` 
        - 장점
            + 인덱스 기반 접근이 O(1)로 매우 빠름
                - 내부적으로 배열을 사용하기 때문에 인덱스로 메모리 주소를 바로 계산 가능하기 때문에
            + 메모리 효율적(연속된 메모리 공간 사용)
            + 캐시 친화적(연속된 메모리 공간 사용 -> 캐시 히트율 높음)
        - 단점
            + 중간 삽입/삭제시 O(n) (요소들을 이동시켜야 함)
            + 용량 확장시 전체 복사 필요
    + 사용케이스
        - 조회가 많고 삽입/삭제가 적은 경우

* LinkedList
    + 내부구조 : 이중 연결 리스트(Double Linked List)
        - 각 노드가 이전/다음 노드의 참조를 가짐
            ```java
            // 내부 노드 구조 (개념적)
            class Node {
                Object data;
                Node prev;
                Node next;
            }
            ```
        - 장점
            + 중간 삽입/삭제가 O(1) (위치를 안다면)
            + 메모리 동적 할당으로 크기 제한없음
        - 단점
            + 인덱스 접근이 O(N) (처음부터 순차탐색)
            + 추가 메모리 오버헤드
    + 사용케이스
        - 삽입/삭제가 빈번하고 순차 접근하는 경우

* Vector
    + 내부구조 : ArrayList와 동일한 동적 배열
        - `모든 메서드가 synchronized`
    + 특징
        - Thread-safe하지만 성능 저하
        - 용량 부족시 2배씩 확장
        - 레거시 클래스 (호환성을 위해 남아있다)

### Set 인터페이스
* HashSet
    + 내부구조 : 해시 테이블
        - 내부적으로 HashMap을 사용
        - 해시 함수를 통해 버킷에 분산하여 저장
    + 성능
        - 평균적인 삽입/삭제/검색(O(1))
    + 특징
        - 순서 보장하지 않음
        - null 값 허용
        - equals()와 hashCode() 구현 필요
    
* 해시테이블의 기본 구조  
해시테이블은 배열처럼 생긴 버킷이 있고 각 객체는 해시값에 따라 특정 버킷에 저장된다

```java
// HashSet 내부 구조 (개념적)
버킷 인덱스:  [0] [1] [2] [3] [4] [5] [6] [7] ...
              |   |   |   |   |   |   |   |
             null A  null C   B  null null ...

HashSet<String> set = new HashSet<>();
set.add("Apple");  // "Apple"을 어느 버킷에 넣을까?
```

단계별 과정
1. hashCode() 호출 : "Apple".hashCode()
2. 버킷 인덱스 계산 : 63476538 % 16 -> 10번 버킷
3. 10번 버킷에 저장

+ 문제상황1
    - hashCode()만 있고 equals()가 없는 경우

        ```java
        // 동작 과정
        Person p1 = new Person("김철수", 25);  // hashCode() = 100
        Person p2 = new Person("김철수", 25);  // hashCode() = 100 (같음!)

        set.add(p1);  // 버킷[4]에 저장
        set.add(p2);  // 1. hashCode() 같음 → 버킷[4]로 이동
                    // 2. 버킷[4]에 p1 있음 → equals() 비교
                    // 3. p1.equals(p2) = false (Object.equals는 ==비교)
                    // 4. 결론: 같은 버킷에 체이닝으로 저장!
        ```
        > 같은 버킷 안에 있으나 동일한 객체 2개 존재

+ 문제상황2
    - equals()만 있고 hashCode()가 없는 경우
        ```java
        // 동작 과정
        Person p1 = new Person("김철수", 25);  // hashCode() = 366712642
        Person p2 = new Person("김철수", 25);  // hashCode() = 1829164700 (다름!)

        set.add(p1);  // 버킷[2]에 저장
        set.add(p2);  // 1. hashCode() 다름 → 버킷[12]로 이동
                    // 2. 버킷[12] 비어있음 → 바로 저장
                    // 3. equals() 비교 기회조차 없음!
        ```
        > 서로 다른 버킷에 논리적으로 동일한 객체 2개 저장

* LinkedHashSet
    + 내부구조 : HashSet + 연결 리스트
        - HashSet의 기능 + 삽입 순서 유지
    + 특징
        - HashSet보다 성능 오버헤드
        - 삽입 순서대로 iteration 가능
        - 예측 가능한 순서가 필요할 때 사용

* TreeSet
    + 내부구조 : Red-Black Tree (자가 균형 이진 탐색 트리)
    + 내부적으로 TreeMap 사용
    + 특징
        - 자동 정렬(Comparable, Comparator 필요)
        - 범위 검색 메서드 제공
        - not null

        ```java
        TreeSet<Integer> treeSet = new TreeSet<>();
        treeSet.add(3); treeSet.add(1); treeSet.add(2);
        System.out.println(treeSet); // [1, 2, 3] - 자동 정렬
        ```

### Map 인터페이스
* HashMap
    + 내부구조 : 해시 테이블 + 체이닝
    + 기본 버킷 크기 : 16
    + 로드 팩터 : 0.75
        - 버킷의 75%가 채워지면 크기 2배 확장
    + 특징
        - key/value 모두 null 허용(key는 하나만)
        - 순서 보장하지 않음(해시값으로 저장하므로)
        - Thread-unsafe

        ```java
        // HashMap 내부 (개념적)
        class HashMap<K,V> {
            Node<K,V>[] table;  // 해시 테이블 (배열)
            
            static class Node<K,V> {
                final int hash;
                final K key;
                V value;
                Node<K,V> next;  // 체이닝용
            }
        }
        ```

        ```java
        HashMap<String, Integer> map = new HashMap<>();
        map.put("Apple", 1);   // hashCode() % 16 = 5번 버킷
        map.put("Banana", 2);  // hashCode() % 16 = 12번 버킷  
        map.put("Cherry", 3);  // hashCode() % 16 = 3번 버킷
        map.put("Date", 4);    // hashCode() % 16 = 8번 버킷

        // 버킷 배열 상태
        [0][1][2][3:Cherry][4][5:Apple][6][7][8:Date][9][10][11][12:Banana][13][14][15]
        ```
        > 저장과정에서 해시값에 의해 결정되는 버킷 위치가 삽입 순서와 무관하므로 순서 보장하지 않음

* LinkedHashMap
    + 내부구조 : HashMap + 이중 연결 리스트
    + 삽입 순서 및 접근 순서 유지 가능
        - HashMap처럼 해시 테이블에 저장
        - 추가로 연결 리스트에도 연결(순서보장)

        ```java
        // LinkedHashMap 내부 구조 (개념적)
        class LinkedHashMap<K,V> extends HashMap<K,V> {
            // HashMap의 해시 테이블
            Node<K,V>[] table;
            
            // 추가: 순서 유지를 위한 이중 연결 리스트
            Entry<K,V> head;  // 첫 번째 노드
            Entry<K,V> tail;  // 마지막 노드
            
            static class Entry<K,V> extends HashMap.Node<K,V> {
                Entry<K,V> before;  // 이전 노드 (순서상)
                Entry<K,V> after;   // 다음 노드 (순서상)
            }
        }
        ```

        ```java
        // 첫 번째 삽입 후
        해시 테이블: [...][5:Apple][...]
        연결 리스트: head → Apple ← tail

        // 두 번째 삽입 후  
        해시 테이블: [...][5:Apple][...][12:Banana][...]
        연결 리스트: head → Apple ⇄ Banana ← tail
        ```

    + 특징
        - insertion-order
            + 기본값
                ```java
                LinkedHashMap<String, Integer> map = new LinkedHashMap<>();
                map.put("A", 1);
                map.put("B", 2);
                map.put("A", 10);  // 기존 키 업데이트

                // 순서: A → B (A는 맨 앞 위치 유지)
                ```

        - access-order
            + 가장 최근 조회한 요소가 tail쪽으로 이동
            + 레디스에서 LRU 캐시로 자주 사용됨
            ```java
            LinkedHashMap<String, Integer> map = new LinkedHashMap<>(16, 0.75f, true);

            map.put("A", 1);  // [A]
            map.put("B", 2);  // [A, B]
            map.put("C", 3);  // [A, B, C]

            map.get("A");     // A를 조회 → A가 tail로 이동
                            // [B, C, A]

            map.get("B");     // B를 조회 → B가 tail로 이동  
                            // [C, A, B]
            ```

        - 배열의 장점인 직접 접근(O(1))과 연결 리스트의 장점인 삽입/삭제(O(1))의 장점만 합친 자료구조

* TreeMap
    + 내부구조 : Red-Black Tree
    + 키 기준으로 정렬된 상태 유지
    + 특징
        - 자동 정렬(key 기준)
        - 범위 검색 메서드 제공
            + subMap(), headMap(), tailMap()
            + floorEntry(), lowerEntry(), ceilingEntry(), higherEntry()
            + firstEntry(), lastEntry()

            ```java
            TreeMap<Integer, String> students = new TreeMap<>();
            students.put(95, "김우수"); students.put(87, "이보통");
            students.put(76, "박평균"); students.put(91, "최우등");
            students.put(82, "정중간");

            // 80점 이상 90점 미만 학생들
            NavigableMap<Integer, String> goodStudents = students.subMap(80, true, 90, false);
            System.out.println("80~89점: " + goodStudents); // {82=정중간, 87=이보통}

            // 90점 이상 우수 학생들
            SortedMap<Integer, String> excellentStudents = students.tailMap(90);
            System.out.println("90점 이상: " + excellentStudents); // {91=최우등, 95=김우수}
            ```
