블로킹과 논블로킹
+ 블로킹 IO
    ```java
    // 데이터를 읽는 동안 여기서 멈춰있음
    int data = inputStream.read();  // ← 이 줄에서 데이터가 올 때까지 대기
    // 데이터가 도착해야 다음 줄 실행
    System.out.println(data);
    ```

    - 작업이 완료될 때까지 스레드가 대기
    - 간단하지만 기다리는 동안 CPU가 낭비
    - 서버에서 동시에 100명이 접속하면? 100개의 스레드가 필요(메모리 부담 up)

+ 논블로킹 IO
    ```java
    // 논블로킹 모드 설정
    channel.configureBlocking(false);

    // 데이터 읽기 시도
    int bytesRead = channel.read(buffer);

    if (bytesRead > 0) {
        // 데이터가 있으면 처리
        processData(buffer);
    } else {
        // 데이터 없으면 다른 일 하러 감
        doOtherWork();
    }
    ```

    - 데이터가 준비되지 않았으면 `즉시 리턴`
    - 스레드가 블록되지 않고 다른 일을 계속 할 수 있음
    - 하지만 데이터가 준비되었나 계속해서 확인해야함(polling)

차이점 정리
|구분|블로킹 IO|논블로킹 IO|
|---|---|---|
|대기 방식|작업 완료까지 멈춤|즉시 리턴, 계속 진행|
|스레드 상태|대기|실행|
|리소스 효율|요청 당 스레드 방식|스레드 적게 필요|
|구현 난이도|쉬움|어려움(상태 관리가 추가되므로)|
|적합한 경우|단순한 요청-응답|대량 연결 처리|

왜 중요할까?
블로킹 방식은 요청 당 스레드로 처리되므로 사용자 1명당 스레드 1개가 필요하다
사용자가 계속해서 늘어나면 그만큼 필요한 스레드 수도 늘어나는 상황

논블로킹은 스레드 몇개로 수천명을 처리할 수 있다
하지만 코드가 복잡해짐
그래서 `가상 스레드`나 `리액터 패턴`과 같은 방법이 등장했다

셀렉터 패턴이란?
Selector는 `여러개의 채널을 하나의 채널이 감시하는 패턴`이다

동작원리
1. 준비(등록)

```java
// Selector 생성
Selector selector = Selector.open();

// 서버 소켓 채널 생성 및 논블로킹 설정
ServerSocketChannel serverSocket = ServerSocketChannel.open();
serverSocket.configureBlocking(false);  // 중요!
serverSocket.bind(new InetSocketAddress(8080));

// Selector에 등록 - "새 연결 올 때 알려줘!"
serverSocket.register(selector, SelectionKey.OP_ACCEPT);
```

2. 감시(대기)

```java
while (true) {
    // 준비된 이벤트가 있을 때까지 대기 (여기서만 블로킹!)
    selector.select();  
    
    // 준비된 이벤트들 가져오기
    Set<SelectionKey> selectedKeys = selector.selectedKeys();
    Iterator<SelectionKey> iterator = selectedKeys.iterator();
    
    while (iterator.hasNext()) {
        SelectionKey key = iterator.next();
        iterator.remove();  // 처리한 이벤트는 제거
        
        // 이벤트 타입별로 처리
        if (key.isAcceptable()) {
            handleAccept(key);      // 새 연결
        } else if (key.isReadable()) {
            handleRead(key);        // 데이터 읽기
        } else if (key.isWritable()) {
            handleWrite(key);       // 데이터 쓰기
        }
    }
}
```

3. 처리

```java
// 새 연결 처리
private void handleAccept(SelectionKey key) {
    ServerSocketChannel server = (ServerSocketChannel) key.channel();
    SocketChannel client = server.accept();  // 논블로킹이라 즉시 리턴
    
    client.configureBlocking(false);
    // 이 클라이언트도 Selector에 등록 - "데이터 오면 알려줘!"
    client.register(selector, SelectionKey.OP_READ);
}

// 데이터 읽기 처리
private void handleRead(SelectionKey key) {
    SocketChannel client = (SocketChannel) key.channel();
    ByteBuffer buffer = ByteBuffer.allocate(1024);
    
    int bytesRead = client.read(buffer);  // 논블로킹 읽기
    
    if (bytesRead > 0) {
        buffer.flip();
        // 데이터 처리
        processData(buffer);
        
        // 이제 쓰기 준비됨을 알려달라고 등록
        key.interestOps(SelectionKey.OP_WRITE);
    } else if (bytesRead == -1) {
        // 연결 종료
        client.close();
    }
}
```

```
스레드 1개 → Selector가 감시 → 메모리 1MB만 소비
일 있을 때만 깨어남 ⚡

[Selector] - 감시자
    |
    |-- [ServerSocketChannel] (연결 대기중)
    |
    |-- [SocketChannel 1] (읽기 준비됨!) ✅
    |-- [SocketChannel 2] (대기중...)
    |-- [SocketChannel 3] (쓰기 준비됨!) ✅
    |-- [SocketChannel 4] (대기중...)
    |-- ...
    |-- [SocketChannel 1000] (대기중...)
```

+ 셀렉터 패턴이 감시할 수 있는 이벤트
    - SelectionKey.OP_ACCEPT   // 새 연결 수락 가능
        + 서버 전용 이벤트
        + 클라이언트가 connect()를 호출했을 때
        + 3-way handshake 완료 후, 서버 측에서 요청을 수락 가능할 때
    - SelectionKey.OP_CONNECT  // 연결 완료
        + 클라이언트 전용
        + 논블로킹 connect() 호출 후
        + 서버와의 연결이 실제로 완료됐을 때
    - SelectionKey.OP_READ     // 읽기 가능
        + 상대방이 데이터를 보냈을 때
        + 읽을 데이터가 버퍼에 도착했을 때
        + 연결이 종료되었을 때(read()는 -1 반환)
    - SelectionKey.OP_WRITE    // 쓰기 가능
        + 소켓 버퍼에 쓸 공간이 있을 때
        + 대부분 true를 리턴(버퍼는 대부분 여유공간이 있으므로)
    - 왜 4개가 다인가?
        + OS 레벨 IO 멀티플렉싱의 한계(OS가 제공하는 기본 이벤트의 한계)
        + Netty는 4가지 기본 이벤트를 기반으로 좀 더 확장된 기능의 이벤트를 제공

+ 장점
    - 리소스 효율적 : 스레드를 적게 사용하니까
    - 확장성 좋음 : 채널만 추가하면 된다
    - 메모리 절약 : 컨텍스트 스위칭 비용 감소

+ 단점
    - 코드 복잡 : 상태 관리가 어려움
    - 디버깅 어려움 : 비동기라 흐름 파익이 어려움
    - CPU 작업 부적합 : IO 대기가 많을 때 유리

IO 멀티플렉싱이란?
네트워크 프로그래밍에서 `여러개의 IO 채널을 하나의 스레드가 감시`하는 방식

+ 전통적 방식(동기)
    ```java
    // 클라이언트 1명당 스레드 1개
    while (true) {
        Socket client = serverSocket.accept();  // 블로킹
        
        new Thread(() -> {
            InputStream in = client.getInputStream();
            int data = in.read();  // 블로킹
            process(data);
        }).start();
    }
    ```

    **문제점:**
    ```
    [클라이언트 1] ─── [스레드 1] (대기 중... 😴)
    [클라이언트 2] ─── [스레드 2] (대기 중... 😴)
    [클라이언트 3] ─── [스레드 3] (대기 중... 😴)
    ...
    [클라이언트 1000] ─── [스레드 1000] (대기 중... 😴)

    메모리: 1000개 * 1MB = 1GB!
    대부분 시간을 놀면서 보냄
    ```

+ 멀티플렉싱
    ```java
    Selector selector = Selector.open();

    // 여러 채널을 하나의 Selector에 등록
    channel1.register(selector, SelectionKey.OP_READ);
    channel2.register(selector, SelectionKey.OP_READ);
    channel3.register(selector, SelectionKey.OP_READ);
    // ... 1000개 등록

    while (true) {
        // 모든 채널을 한 번에 감시
        selector.select();  // "준비된 채널 있으면 알려줘!"
        
        // 준비된 채널만 처리
        for (SelectionKey key : selector.selectedKeys()) {
            if (key.isReadable()) {
                handleRead(key);
            }
        }
    }
    ```

    **장점:**
    ```
    [클라이언트 1]  ╲
    [클라이언트 2]   ├─── [Selector] ─── [스레드 1개]
    [클라이언트 3]   │
    ...              │
    [클라이언트 1000]╱

    메모리: 거의 그대로 (스레드 1개!)
    준비된 채널만 처리하니까 효율적!
    ```

자바의 멀티플렉싱은 내부적으로 OS의 멀티플렉싱을 사용  
JVM이 알아서 선택하므로 개발자는 신경쓸 필요가 없다

멀티스레딩vs멀티플렉싱
