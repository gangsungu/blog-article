## 트랜잭션 격리수준이란?
데이터베이스에서 여러 트랜잭션이 동시에 실행될 때, 각 트랜잭션이 다른 트랜잭션의 영향을 얼마나 받을지  
결정하는 것이 **격리수준(Isolation Level)**

* 동시성 문제들
    + Dirty Read
        - 아직 커밋되지 않은(롤백 가능성있는) 데이터를 읽는 현상
        - A 계좌가 10만원 출금 > B가 잔액을 조회 > A가 롤백 > 실제로는 100만원인데, B는 90만원으로 알고있음

    + Non-Repeatable Read
        - 같은 트랜잭션 내에서 같은 데이터를 두번 읽었는데, 다른 결과가 나오는 현상
        - A가 상품 가격 조회(10만원) > B가 가격 수정(1만원) > A가 다시 조회(1만원)

    + Phantom Read
        - 같은 조건으로 조회했는데, 이전에 없던 레코드가 나타나는 현상
        - A가 가격 > 1만원 조회(10개) > B가 새 상품 추가 > A가 다시 조회(11개)

### 4가지 격리수준

+ READ UNCOMMITTED (레벨 0)
    - 가장 낮은 격리수준
    - 커밋되지 않은 데이터도 읽을 수 있음
    - Dirty Read 발생 가능
    - 성능은 가장 좋지만 데이터 일관성에 문제

+ READ COMMITTED (레벨 1)
    - 커밋된 데이터만 읽을 수 있음
    - Dirty Read 방지
    - Non-Repeatable Read, Phantom Read 발생 가능
    - 대부분 DBMS의 기본 설정

+ REPEATABLE READ (레벨 2)
    - 트랜잭션 시작 시점의 스냅샷을 유지
    - Dirty Read, Non-Repeatable Read 방지
    - Phantom Read 발생 가능 (MySQL InnoDB에서는 방지됨)
    - MySQL의 기본 격리수준

+ SERIALIZABLE (레벨 3)
    - 가장 높은 격리수준
    - 모든 동시성 문제 방지
    - 트랜잭션들이 순차적으로 실행되는 것처럼 동작
    - 성능이 가장 낮음

### 격리수준과 성능의 트레이드오프
격리수준이 높아질수록 데이터 일관성은 향샹되지만 동시성 감소와 성능 저하, 데드락 발생 가능성이 증가한다.

+ 동시성 감소
    - 여러 트랜잭션이 **동시에 실행될 수 있는 능력**, 동시성이 감소한다는 말은 동시에 처리할 수 있는 트랜잭션의 수가 줄어든다는 뜻
    - READ UNCOMMITTED
        ```
        시간: 1초   2초   3초   4초
        트A:  읽기  처리  처리  완료
        트B:    읽기  처리  완료
        트C:      읽기  완료
        ```
    - SERIALIZABLE
        ```
        시간: 1초   2초   3초   4초   5초   6초
        트A:  읽기  처리  처리  완료
        트B:                  읽기  처리  완료
        트C:                        읽기  완료
        ```
    - 격리수준이 높아질수록 데이터베이스는 더 많은 락을 걸고 더 오래 유지한다
        - 같은 데이터를 수정하려면 `대기`해야 함
        - `대기`가 길어지면 타임아웃 가능성 증가

+ 데드락
    - 두개 이상의 트랜잭션이 서로 가진 락을 기다리며 무한정 대기하는 현상
        ```sql
        -- 트랜잭션 A
        BEGIN;
        UPDATE accounts SET balance = balance - 100 WHERE id = 1; -- 계좌1 락
        -- 이 시점에서 트랜잭션 B 실행
        UPDATE accounts SET balance = balance + 100 WHERE id = 2; -- 계좌2 락 요청 (대기)

        -- 트랜잭션 B  
        BEGIN;
        UPDATE accounts SET balance = balance - 50 WHERE id = 2;  -- 계좌2 락
        UPDATE accounts SET balance = balance + 50 WHERE id = 1;  -- 계좌1 락 요청 (대기)
        ```

+ 격리수준과 데드락의 관계
    - 락을 더 오래 점유 > 다른 트랜잭션과 충돌확률이 올라감
    - 더 많은 데이터에 락 > 복잡한 락 상호작용 가능성이 올라감
    - 락 범위 확대 > 프로세스 진행 중, 우연한 충돌확률 올라감

+ 데드락 해결방법
    - 탐지 & 해결
        - DBMS가 데드락을 감지하면 트랜잭션을 강제로 롤백
    - 방지
        - 락 순서 통일 : 항상 id가 낮은 쪽부터 락 획득
        - 타임아웃 설정
            ```java
            @Transactional(timeout = 30) // 30초 후 자동 롤백
            public void processOrder() {
                // 비즈니스 로직
            }
            ```