## 클러스터 인덱스와 세컨더리 인덱스란?
인덱스는 책의 목차나 찾아보기와 비슷한 개념  
책에서 특정 내용을 찾을 때, 처음부터 끝까지 읽지않고 목차를 보고 해당 페이지로 이동하듯  
데이터베이스에서도 인덱스를 통해 원하는 데이터를 빠르게 찾을 수 있다.

### 클러스터 인덱스
실제 데이터와 인덱스가 같은 위치에 저장되는 인덱스

+ 특징
    - 테이블당 1개만 생성 가능(PK)
    - 실제 데이터 페이지가 인덱스 키 순서로 정렬되어 저장됨
    - 리프 레벨(최하위 레벨)에 실제 데이터가 저장

+ 장점
    - 범위 검색에 매우 빠름(연속된 데이터가 물리적으로 인접)
    - 추가적인 키 룩업이 불필요(인덱스가 데이터라서)

+ 단점
    - INSERT/UPDATE/DELETE 시 데이터 재정렬로 인한 오버헤드
    - 테이블당 하나만 생성가능

### 세컨더리 인덱스
실제 데이터와 별도로 저장되는 인덱스

+ 특징
    - 테이블당 여러개 생성 가능
    - 리프 레벨에 실제 데이터가 아닌 포인터나 클러스터 인덱스 키가 저장됨
    - 인덱스와 실제 데이터가 분리되어 있음

+ 장점
    - 여러개 생성이 가능해서 다양한 쿼리 패턴에 대응가능
    - 특정 컬럼에 대한 빠른 검색 제공
    - 클러스터 인덱스보다 INSERT/UPDATE시 오버헤드가 적음

+ 단점
    - 키 룩업이 필요할 수 있음(인덱스 > 실제 데이터)
    - 저장공간을 더 많이 사용

### 실제 동작 예시로 살펴보기

```sql
-- 예시 테이블
CREATE TABLE Users (
    UserID int PRIMARY KEY,      -- 클러스터 인덱스
    Email varchar(100),
    Name varchar(50),
    Age int
);

CREATE INDEX IX_Email ON Users(Email);  -- 세컨더리 인덱스
```

+ 클러스터 인덱스 검색 시
    - SELECT * FROM Users WHERE UserID = 100
        - UserID 순서로 정렬된 데이터에서 바로 찾아서 모든 컬럼 반환

+ 세컨더리 인덱스 검색 시
    - SELECT * FROM Users WHERE Email = 'john@example.com'
        - Email 인덱스에서 해당 이메일 찾기
        - 거기서 UserID(클러스터 키) 가져오기
        - UserID로 실제 데이터 페이지에서 전체 행 조회 (Key Lookup)

+ 성능비교
    ```sql
    -- 이 경우 Name 인덱스가 더 빠를 수 있음 (커버링 인덱스라면)
    SELECT Name FROM Users WHERE Name LIKE 'Kim%'

    -- 이 경우 클러스터 인덱스가 더 빠름  
    SELECT * FROM Users WHERE UserID BETWEEN 100 AND 200
    ```

### 키 룩업
세컨더리 인덱스에서 찾은 키 값으로 클러스터 인덱스에 접근하여 추가 데이터를 가져오는 과정

* 왜 키 룩업이 발생할까?  
    + 세컨더리 인덱스는 `인덱스 키 칼럼 + 클러스터 키`만 저장하고 있어 다른 컬럼이 필요하면 실제 데이터를 찾아야 한다
        ```sql
        -- 테이블 구조
        CREATE TABLE Users (
            UserID int PRIMARY KEY,        -- 클러스터 인덱스
            Email varchar(100),
            Name varchar(50), 
            Age int,
            Address varchar(200)
        );

        CREATE INDEX IX_Email ON Users(Email);  -- Email에만 인덱스
        ```

        ```sql
        -- 세컨더리 인덱스 IX_Email
        Email                | UserID (클러스터 키)
        --------------------|-------------------
        alice@test.com      | 100
        bob@test.com        | 200  
        charlie@test.com    | 300
        ```

        ```sql
        -- 클러스터 인덱스(실제 데이터)
        UserID | Email           | Name    | Age | Address
        -------|-----------------|---------|-----|----------------
        100    | alice@test.com  | Alice   | 25  | Seoul, Korea
        200    | bob@test.com    | Bob     | 30  | Busan, Korea  
        300    | charlie@test.com| Charlie | 28  | Incheon, Korea
        ```
    
    + 키 룩업이 발생하는 경우
        ```sql
        -- 키 룩업 발생 O
        SELECT Name, Age, Address 
        FROM Users 
        WHERE Email = 'alice@test.com'
        ```
        - IX_Email에서 'alice@test.com' 찾기 > UserID 100 발견
        - 키 룩업 > UserID = 100(클러스터 인덱스)로 실제 데이터 name, age, address 조회

    + 키 룩업이 발생하지 않는 경우
        ```sql
        -- 키 룩업 발생 X  
        SELECT Email 
        FROM Users 
        WHERE Email = 'alice@test.com'

        -- 키 룩업 발생 X (UserID는 클러스터 키라서 세컨더리 인덱스에 포함됨)
        SELECT Email, UserID
        FROM Users  
        WHERE Email = 'alice@test.com'
        ```

    + 키 룩업을 피하는 경우
        - 커버링 인덱스
        - 복합 인덱스